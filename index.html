<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŒ–å­¦å§åº•</title>
    <style>
        /* æ ·å¼éƒ¨åˆ†ä¿æŒä¸å˜ï¼Œä¸åŸå§‹ä»£ç ç›¸åŒ */
        :root {
            --primary: #4a6fa5;
            --secondary: #6b8cbc;
            --accent: #ff6b6b;
            --light: #f8f9fa;
            --dark: #343a40;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --chemist: #4a9c78;
            --undercover: #c44545;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            width: 100%;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: white;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .tagline {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .game-area {
            display: flex;
            gap: 20px;
            height: 70vh;
        }
        
        .left-panel {
            flex: 3;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .right-panel {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .game-log {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .message {
            padding: 12px 15px;
            border-radius: 12px;
            max-width: 85%;
            line-height: 1.5;
            animation: fadeIn 0.3s ease;
            white-space: pre-line;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-message {
            align-self: flex-end;
            background: var(--primary);
            color: white;
            border-bottom-right-radius: 5px;
        }
        
        .ai-message {
            align-self: flex-start;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border-bottom-left-radius: 5px;
        }
        
        .system-message {
            align-self: center;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-style: italic;
            text-align: center;
            max-width: 95%;
            font-size: 0.9rem;
            padding: 8px 12px;
        }
        
        .player-message {
            align-self: flex-start;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-bottom-left-radius: 5px;
            border-left: 4px solid var(--secondary);
        }
        
        .error-message {
            align-self: center;
            background: rgba(220, 53, 69, 0.3);
            color: white;
            border: 1px solid rgba(220, 53, 69, 0.5);
            max-width: 95%;
        }
        
        .input-area {
            display: flex;
            gap: 10px;
        }
        
        .input-area input {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        
        .input-area input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }
        
        .input-area input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }
        
        .input-area input.error {
            border: 2px solid var(--danger);
            background: rgba(220, 53, 69, 0.1);
        }
        
        .btn {
            padding: 15px 25px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .btn-primary:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }
        
        .btn-start {
            background: var(--success);
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            font-size: 1.1rem;
            padding: 18px 30px;
        }
        
        .btn-start:hover {
            background: #34ce57;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .game-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .info-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .my-concept {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            text-align: center;
            border: 2px dashed rgba(255, 255, 255, 0.3);
        }
        
        .concept-name {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 10px 0;
            color: var(--light);
        }
        
        .concept-role {
            font-size: 1rem;
            padding: 5px 15px;
            border-radius: 20px;
            display: inline-block;
            margin-top: 5px;
            opacity: 0;
            height: 0;
            transition: all 0.5s ease;
        }
        
        .concept-role.revealed {
            opacity: 1;
            height: auto;
            margin-top: 10px;
        }
        
        .role-chemist {
            background: var(--chemist);
        }
        
        .role-undercover {
            background: var(--undercover);
        }
        
        .rules {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            overflow-y: auto;
        }
        
        .rules h3 {
            margin-bottom: 15px;
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .rules-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .rule-item {
            display: flex;
            gap: 12px;
        }
        
        .rule-number {
            background: var(--accent);
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            flex-shrink: 0;
        }
        
        .player-cards {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
            transition: all 0.3s ease;
        }
        
        .player-card {
            width: 120px;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }
        
        .player-card.active {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .player-card.voting {
            border: 2px solid var(--warning);
        }
        
        .player-card.voted {
            border: 2px solid var(--success);
        }
        
        .player-card.eliminated {
            opacity: 0.5;
            background: rgba(255, 255, 255, 0.05);
            filter: grayscale(70%);
        }
        
        .player-card.tie {
            border: 2px solid var(--accent);
            animation: pulseTie 1.5s infinite;
        }
        
        .player-card.unavailable {
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        @keyframes pulseTie {
            0% { border-color: var(--accent); }
            50% { border-color: var(--warning); }
            100% { border-color: var(--accent); }
        }
        
        .vote-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--accent);
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: white;
        }
        
        .player-name {
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .player-status {
            font-size: 0.8rem;
            opacity: 0.8;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--success);
        }
        
        .status-dot.thinking {
            background: var(--warning);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .footer {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            font-size: 0.9rem;
            opacity: 0.7;
        }
        
        .start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            text-align: center;
            padding: 40px;
        }
        
        .start-title {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: white;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .start-description {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 600px;
            line-height: 1.6;
        }
        
        .player-name-input {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
            align-items: center;
        }
        
        .player-name-input input {
            padding: 12px 15px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 1rem;
            width: 250px;
            text-align: center;
        }
        
        .player-name-input input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.25);
        }
        
        .player-name-input input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }
        
        .victory-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }
        
        .victory-content {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .victory-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: white;
        }
        
        .victory-message {
            font-size: 1.2rem;
            margin-bottom: 25px;
            line-height: 1.6;
        }
        
        .victory-stats {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent);
        }
        
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .victory-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }
        
        /* çŸ¥è¯†ç‚¹é€‰æ‹©æ ·å¼ä¼˜åŒ– */
        .knowledge-selection {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
            max-width: 700px;
            width: 100%;
        }
        
        .knowledge-title {
            font-size: 1.3rem;
            margin-bottom: 10px;
            color: white;
            text-align: center;
        }
        
        .knowledge-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
        }
        
        .knowledge-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .knowledge-card:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .knowledge-card.selected {
            background: rgba(74, 111, 165, 0.3);
            border-color: var(--primary);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .knowledge-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .knowledge-card-checkbox {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .knowledge-card.selected .knowledge-card-checkbox {
            background: var(--primary);
            border-color: var(--primary);
        }
        
        .knowledge-card.selected .knowledge-card-checkbox::after {
            content: "âœ“";
            color: white;
            font-weight: bold;
        }
        
        .knowledge-card-name {
            font-weight: 600;
            font-size: 1rem;
        }
        
        .knowledge-card-concepts {
            font-size: 0.85rem;
            opacity: 0.8;
            line-height: 1.4;
            display: none; /* éšè—å…·ä½“è¯æ±‡ */
        }
        
        .select-all {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
        }
        
        /* çŸ¥è¯†ç‚¹æ€»ç»“æ¨¡æ€æ¡† */
        .summary-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1001;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }
        
        .summary-content {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 30px;
            border-radius: 20px;
            text-align: left;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .summary-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: white;
            text-align: center;
        }
        
        .summary-text {
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 20px;
            white-space: pre-line;
        }
        
        .summary-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        /* ç§»åŠ¨è®¾å¤‡ä¼˜åŒ– */
        .mobile-controls {
            display: none;
        }
        
        .voting-toggle {
            display: none;
        }
        
        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
                height: auto;
            }
            
            .player-cards {
                justify-content: space-around;
                max-height: 0;
                overflow: hidden;
                padding: 0;
                margin-top: 0;
                opacity: 0;
            }
            
            .player-cards.expanded {
                max-height: 500px;
                padding: 10px;
                margin-top: 10px;
                opacity: 1;
            }
            
            .voting-toggle {
                display: flex;
                justify-content: center;
                margin-top: 10px;
            }
            
            .mobile-controls {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                justify-content: center;
                margin-top: 15px;
            }
            
            .mobile-controls .btn {
                flex: 1;
                min-width: 120px;
                padding: 12px 15px;
                font-size: 0.9rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .start-title {
                font-size: 2rem;
            }
            
            .start-description {
                font-size: 1rem;
            }
            
            .victory-title {
                font-size: 2rem;
            }
            
            .victory-message {
                font-size: 1rem;
            }
            
            .knowledge-grid {
                grid-template-columns: 1fr;
            }
            
            .victory-buttons {
                flex-direction: column;
            }
            
            .input-area {
                flex-direction: column;
            }
            
            .player-card {
                width: 100px;
                height: 130px;
            }
            
            .player-avatar {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }
            
            .player-name {
                font-size: 0.8rem;
            }
            
            .player-status {
                font-size: 0.75rem;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 10px;
            }
            
            .container {
                gap: 15px;
            }
            
            header {
                padding: 15px;
            }
            
            .game-log, .game-info, .rules {
                padding: 15px;
            }
            
            .player-card {
                width: 85px;
                height: 120px;
            }
            
            .player-avatar {
                width: 45px;
                height: 45px;
                font-size: 1.1rem;
            }
            
            .player-name {
                font-size: 0.75rem;
            }
            
            .player-status {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="startScreen" class="start-screen">
            <h1 class="start-title">ğŸ§ª åŒ–å­¦å§åº•</h1>
            <p class="start-description">
                é€šè¿‡æè¿°åŒ–å­¦æ¦‚å¿µï¼Œæ‰¾å‡ºéšè—çš„å§åº•ï¼è¯·å…ˆé€‰æ‹©ä½ æƒ³è¦ç»ƒä¹ çš„çŸ¥è¯†ç‚¹ã€‚
            </p>
            
            <div class="player-name-input">
                <input type="text" id="playerNameInput" placeholder="è¯·è¾“å…¥ä½ çš„æ˜µç§°æˆ–å§“å" maxlength="20">
            </div>
            
            <div class="knowledge-selection">
                <h3 class="knowledge-title">ğŸ“š é€‰æ‹©çŸ¥è¯†ç‚¹</h3>
                <div class="knowledge-grid" id="knowledgeGrid">
                    <!-- çŸ¥è¯†ç‚¹å¡ç‰‡å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                </div>
                <div class="select-all">
                    <button class="btn btn-secondary" onclick="selectAllKnowledge()">
                        <span>âœ“</span> å…¨é€‰
                    </button>
                    <button class="btn btn-secondary" onclick="deselectAllKnowledge()">
                        <span>âœ—</span> å…¨ä¸é€‰
                    </button>
                </div>
            </div>
            
            <button class="btn btn-start" onclick="startNewGame()">
                <span>ğŸ®</span> å¼€å¯æ¸¸æˆ
            </button>
        </div>
        
        <div id="gameScreen" style="display: none;">
            <header>
                <h1>ğŸ§ª åŒ–å­¦å§åº•</h1>
                <p class="tagline">é€šè¿‡æè¿°åŒ–å­¦æ¦‚å¿µï¼Œæ‰¾å‡ºéšè—çš„å§åº•ï¼</p>
                <div class="mobile-controls">
                    <button class="btn btn-secondary" onclick="showRules()">
                        <span>ğŸ“‹</span> è§„åˆ™
                    </button>
                    <button class="btn btn-secondary" onclick="clearChat()">
                        <span>ğŸ—‘ï¸</span> æ¸…ç©º
                    </button>
                    <button class="btn btn-secondary" onclick="restartGame()">
                        <span>ğŸ”„</span> é‡å¼€
                    </button>
                </div>
            </header>
            
            <div class="game-area">
                <div class="left-panel">
                    <div class="game-log" id="gameLog">
                        <!-- æ¸¸æˆæ—¥å¿—å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                    
                    <div class="input-area">
                        <input type="text" id="playerInput" placeholder="è¯·è¾“å…¥ä½ çš„æè¿°..." autocomplete="off" disabled maxlength="100">
                        <button class="btn btn-primary" onclick="sendMessage()" id="sendBtn" disabled>
                            <span>å‘é€</span>
                        </button>
                    </div>
                </div>
                
                <div class="right-panel">
                    <div class="game-info">
                        <h2 class="info-title">ğŸ¯ æˆ‘çš„è¯å¡</h2>
                        <div class="status-indicator">
                            <div class="status-dot" id="statusDot"></div>
                            <span id="statusText">ç­‰å¾…æ¸¸æˆå¼€å§‹</span>
                        </div>
                        
                        <div class="my-concept">
                            <div>ä½ çš„æ¦‚å¿µæ˜¯ï¼š</div>
                            <div class="concept-name" id="myConcept">ç­‰å¾…åˆ†é…...</div>
                            <div class="concept-role" id="myRole">æ¸¸æˆç»“æŸåæ­ç¤º</div>
                        </div>
                    </div>
                    
                    <div class="rules">
                        <h3>ğŸ“– æ¸¸æˆè§„åˆ™</h3>
                        <div class="rules-list">
                            <div class="rule-item">
                                <div class="rule-number">1</div>
                                <div>ç©å®¶ä¾æ¬¡ç”¨ä¸€å¥è¯æè¿°è‡ªå·±æ‹¿åˆ°çš„åŒ–å­¦æ¦‚å¿µï¼Œæè¿°ä¸èƒ½ç›´æ¥è¯´å‡ºå®Œæ•´çš„æ¦‚å¿µåç§°ï¼Œæ‰€æœ‰ç©å®¶æè¿°å®Œæ¯•åè¿›è¡ŒæŠ•ç¥¨ï¼Œæ‰¾å‡ºå§åº•</div>
                            </div>
                            <div class="rule-item">
                                <div class="rule-number">2</div>
                                <div>å¹³ç¥¨æ—¶ï¼Œå¹³ç¥¨ç©å®¶è¿›è¡Œé¢å¤–æè¿°ï¼Œç„¶åé‡æ–°æŠ•ç¥¨ï¼›å¦‚å¹³ç¥¨è¾¾3æ¬¡ï¼Œéšæœºæ·˜æ±°ä¸€åå¹³ç¥¨é€‰æ‰‹</div>
                            </div>
                            <div class="rule-item">
                                <div class="rule-number">3</div>
                                <div>å¦‚æœå§åº•åšæŒåˆ°æœ€åï¼Œå§åº•è·èƒœï¼›å¦åˆ™åŒ–å­¦å®¶è·èƒœ</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="voting-toggle">
                <button class="btn btn-secondary" onclick="toggleVotingCards()">
                    <span id="votingToggleIcon">ğŸ‘¥</span> <span id="votingToggleText">æ˜¾ç¤ºç©å®¶å¡ç‰‡</span>
                </button>
            </div>
            
            <div class="player-cards" id="playerCards">
                <div class="player-card" id="player1" data-player-index="0">
                    <div class="player-avatar">ğŸ‘¨â€ğŸ”¬</div>
                    <div class="player-name" id="player1Name">ä½ </div>
                    <div class="player-status">ç­‰å¾…æ¸¸æˆå¼€å§‹</div>
                </div>
                <div class="player-card" id="player2" data-player-index="1">
                    <div class="player-avatar">ğŸ‘©â€ğŸ”¬</div>
                    <div class="player-name">å®éªŒå°æ</div>
                    <div class="player-status">ç­‰å¾…ä¸­</div>
                </div>
                <div class="player-card" id="player3" data-player-index="2">
                    <div class="player-avatar">ğŸ§‘â€ğŸ”¬</div>
                    <div class="player-name">ååº”å°å¼ </div>
                    <div class="player-status">ç­‰å¾…ä¸­</div>
                </div>
                <div class="player-card" id="player4" data-player-index="3">
                    <div class="player-avatar">ğŸ‘¨â€ğŸ’¼</div>
                    <div class="player-name">å…ƒç´ å°èµµ</div>
                    <div class="player-status">ç­‰å¾…ä¸­</div>
                </div>
            </div>
            
            <div class="footer">
                <p>åŒ–å­¦å§åº•æ¸¸æˆ - - ä½¿ç”¨DeepSeek APIé©±åŠ¨ | è¾…åŠ©ä¸­å­¦åŒ–å­¦æ•™å­¦</p>
            </div>
        </div>
    </div>
    
    <div id="victoryScreen" class="victory-screen">
        <div class="victory-content">
            <h2 class="victory-title" id="victoryTitle">ğŸ‰ æ­å–œè·èƒœï¼</h2>
            <p class="victory-message" id="victoryMessage">ä½ å·²è·å¾—1åœºèƒœåˆ©ï¼Œæˆä¸ºåŒ–å­¦å§åº•å¤§å¸ˆï¼</p>
            
            <div class="victory-stats" id="victoryStats">
                <div class="stat-item">
                    <div class="stat-value" id="totalWins">0</div>
                    <div class="stat-label">æ€»èƒœåˆ©åœºæ•°</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalRounds">0</div>
                    <div class="stat-label">æ€»å±€æ•°</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="winRate">0%</div>
                    <div class="stat-label">èƒœç‡</div>
                </div>
            </div>
            
            <div class="victory-buttons">
                <button class="btn btn-start" onclick="saveVictory()" id="saveVictoryBtn">
                    <span>ğŸ’¾</span> ä¿å­˜èƒœåˆ©è®°å½•
                </button>
                <button class="btn btn-secondary" onclick="showSummary()">
                    <span>ğŸ“š</span> æŸ¥çœ‹çŸ¥è¯†ç‚¹æ€»ç»“
                </button>
                <button class="btn btn-secondary" onclick="closeVictoryScreen()">
                    <span>ğŸ”™</span> è¿”å›æ¸¸æˆ
                </button>
            </div>
        </div>
    </div>

    <div id="summaryModal" class="summary-modal">
        <div class="summary-content">
            <h2 class="summary-title">ğŸ“š çŸ¥è¯†ç‚¹æ€»ç»“</h2>
            <div class="summary-text" id="summaryText">
                <!-- çŸ¥è¯†ç‚¹æ€»ç»“å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
            </div>
            <div class="summary-buttons">
                <button class="btn btn-start" onclick="saveSummary()">
                    <span>ğŸ’¾</span> ä¿å­˜æ€»ç»“
                </button>
                <button class="btn btn-secondary" onclick="closeSummary()">
                    <span>âœ•</span> å…³é—­
                </button>
            </div>
        </div>
    </div>

    <script>
        const CONFIG_DATA = {
            a: 'sk-4811bc1da0b54f27a831fca660288c1f',
            b: 'sk-237aefdf550f41b3a380f5b947b9ea24',
            c: 'sk-7ee245209cb3419f8e8850a0988880a1',
            d: 'sk-32f8bc6fcd4447dcbd2e59ba9c3e5294'
        };
        
        const API_BASE_URL = 'https://api.deepseek.com/v1/chat/completions';
        
        // DOMå…ƒç´ 
        const startScreen = document.getElementById('startScreen');
        const gameScreen = document.getElementById('gameScreen');
        const victoryScreen = document.getElementById('victoryScreen');
        const summaryModal = document.getElementById('summaryModal');
        const gameLog = document.getElementById('gameLog');
        const playerInput = document.getElementById('playerInput');
        const sendBtn = document.getElementById('sendBtn');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const myConcept = document.getElementById('myConcept');
        const myRole = document.getElementById('myRole');
        const victoryMessage = document.getElementById('victoryMessage');
        const victoryTitle = document.getElementById('victoryTitle');
        const playerNameInput = document.getElementById('playerNameInput');
        const player1Name = document.getElementById('player1Name');
        const knowledgeGrid = document.getElementById('knowledgeGrid');
        const summaryText = document.getElementById('summaryText');
        const playerCards = document.getElementById('playerCards');
        const votingToggleIcon = document.getElementById('votingToggleIcon');
        const votingToggleText = document.getElementById('votingToggleText');
        const saveVictoryBtn = document.getElementById('saveVictoryBtn');
        const victoryStats = document.getElementById('victoryStats');
        const totalWins = document.getElementById('totalWins');
        const totalRounds = document.getElementById('totalRounds');
        const winRate = document.getElementById('winRate');
        
        // çŸ¥è¯†ç‚¹åº“
        const knowledgePoints = [
            {
                id: 1,
                name: "ç‰©è´¨åˆ†ç±»",
                concepts: [
                    "çº¯å‡€ç‰©ã€æ··åˆç‰©",
                    "å•è´¨ã€åŒ–åˆç‰©",
                    "é…¸ã€ç¢±",
                    "é…¸æ€§æ°§åŒ–ç‰©ã€ç¢±æ€§æ°§åŒ–ç‰©",
                    "æœ‰æœºç‰©ã€æ— æœºç‰©",
                    "æº¶æ¶²ã€ä¹³æµŠæ¶²"
                ]
            },
            {
                id: 2,
                name: "ç‰©è´¨æ€§è´¨ä¸å˜åŒ–",
                concepts: [
                    "ç‰©ç†å˜åŒ–ã€åŒ–å­¦å˜åŒ–",
                    "ç‰©ç†æ€§è´¨ã€åŒ–å­¦æ€§è´¨",
                    "è’¸å‘ã€æ²¸è…¾",
                    "å‚¬åŒ–ã€æ°§åŒ–",
                    "æº¶è§£ã€ç†”åŒ–",
                    "åŒ–åˆååº”ã€åˆ†è§£ååº”"
                ]
            },
            {
                id: 3,
                name: "å¸¸è§ç‰©è´¨ä¸å¾®ç²’",
                concepts: [
                    "åˆ†å­ã€åŸå­",
                    "åŸå­ã€ç¦»å­",
                    "äºŒæ°§åŒ–ç¢³ã€ä¸€æ°§åŒ–ç¢³",
                    "æ°§æ°”ã€è‡­æ°§",
                    "ç”ŸçŸ³ç°ã€ç†ŸçŸ³ç°",
                    "é‡‘åˆšçŸ³ã€çŸ³å¢¨"
                ]
            },
            {
                id: 4,
                name: "åŒ–å­¦å®éªŒä¸æ“ä½œ",
                concepts: [
                    "è’¸å‘ã€è’¸é¦",
                    "ç‚¹ç‡ƒã€åŠ çƒ­",
                    "çƒŸã€é›¾",
                    "é•¿é¢ˆæ¼æ–—ã€åˆ†æ¶²æ¼æ–—",
                    "è¯åŒ™ã€é•Šå­",
                    "æº¶è§£ã€è¿‡æ»¤"
                ]
            },
            {
                id: 5,
                name: "åŒ–å­¦è‚¥æ–™",
                concepts: [
                    "æ°®è‚¥ã€ç£·è‚¥",
                    "é“µç›ã€å°¿ç´ ",
                    "æ°¨æ°´ã€ç¡é…¸é“µ"
                ]
            },
            {
                id: 6,
                name: "åŒ–å­¦åŸç†ä¸æ¦‚å¿µ",
                concepts: [
                    "ç”µç¦»ã€ç”µè§£",
                    "åŸç”µæ± ã€ç”µè§£æ± ",
                    "åŒ–åˆä»·ã€æ°§åŒ–æ•°",
                    "åŒ–å­¦é”®ã€åˆ†å­é—´ä½œç”¨åŠ›",
                    "ç¦»å­é”®ã€å…±ä»·é”®",
                    "ç»“æ™¶ã€æ²‰æ·€"
                ]
            },
            {
                id: 7,
                name: "åŒ–å­¦ååº”ä¸å¹³è¡¡",
                concepts: [
                    "åŒ–åˆååº”ã€æ°§åŒ–è¿˜åŸååº”",
                    "ç”µç¦»å¹³è¡¡ã€æ°´è§£å¹³è¡¡",
                    "å‹’å¤ç‰¹åˆ—åŸç†ã€åŒ–å­¦ååº”é€Ÿç‡",
                    "å¯é€†ååº”ã€åŠ¨æ€å¹³è¡¡",
                    "æ´»åŒ–èƒ½ã€ååº”çƒ­",
                    "ä¸­å’Œååº”ã€ç›ç±»æ°´è§£"
                ]
            },
            {
                id: 8,
                name: "å…ƒç´ åŠå…¶åŒ–åˆç‰©",
                concepts: [
                    "ç›é…¸ã€ç¡«é…¸",
                    "ç¡é…¸ã€é†‹é…¸",
                    "æ°§åŒ–é“ã€æ°¢æ°§åŒ–é“",
                    "è¿‡æ°§åŒ–é’ ã€æ°§åŒ–é’ ",
                    "äºŒæ°§åŒ–ç¡«ã€äºŒæ°§åŒ–ç¢³",
                    "é“ã€é“"
                ]
            },
            {
                id: 9,
                name: "æœ‰æœºåŒ–å­¦åŸºç¡€",
                concepts: [
                    "çƒ·çƒƒã€çƒ¯çƒƒ",
                    "é†‡ã€é…š",
                    "ç¾§é…¸ã€é…¯",
                    "è‘¡è„ç³–ã€æœç³–",
                    "è‹¯ã€ç”²è‹¯",
                    "åŠ æˆååº”ã€å–ä»£ååº”"
                ]
            },
            {
                id: 10,
                name: "åŒ–å­¦å®éªŒä¸ä»ªå™¨",
                concepts: [
                    "æ»´å®šç®¡ã€é‡ç­’",
                    "åœ†åº•çƒ§ç“¶ã€é”¥å½¢ç“¶",
                    "å©åŸšã€è’¸å‘çš¿",
                    "æ¸—æã€ç›æ",
                    "æ´—æ°”ã€å¹²ç‡¥",
                    "åˆ†æ¶²ã€èƒå–"
                ]
            }
        ];
        
        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            currentPlayer: 0,
            players: [
                { name: 'ä½ ', avatar: 'ğŸ‘¨â€ğŸ”¬', status: 'ç­‰å¾…æè¿°', concept: '', role: '', votes: 0, eliminated: false },
                { name: 'å®éªŒå°æ', avatar: 'ğŸ‘©â€ğŸ”¬', status: 'ç­‰å¾…ä¸­', concept: '', role: '', votes: 0, eliminated: false },
                { name: 'ååº”å°å¼ ', avatar: 'ğŸ§‘â€ğŸ”¬', status: 'ç­‰å¾…ä¸­', concept: '', role: '', votes: 0, eliminated: false },
                { name: 'å…ƒç´ å°èµµ', avatar: 'ğŸ‘¨â€ğŸ’¼', status: 'ç­‰å¾…ä¸­', concept: '', role: '', votes: 0, eliminated: false }
            ],
            gamePhase: 'setup',
            concepts: [],
            usedConceptPairs: [],
            currentAIPlayerIndex: 1,
            userVoted: false,
            aiVotes: [],
            roleRevealed: false,
            playerWins: 0,
            totalRounds: 0,
            tiePlayers: [],
            tieRound: 0,
            maxTieRounds: 3,
            roundNumber: 1,
            waitingForUserTieDescription: null,
            selectedKnowledgePoints: [],
            currentConcepts: {},
            knowledgeSummary: '',
            isMobile: window.innerWidth <= 768,
            tieCount: 0,
            playerWon: false,
            // æ–°å¢ï¼šæŠ•ç¥¨è®°å½•æ•°ç»„
            currentVoteRecords: []
        };
        
        // æ‰€æœ‰ç©å®¶çš„æè¿°è®°å½•
        let playerDescriptions = [];
        
        // åˆå§‹åŒ–çŸ¥è¯†ç‚¹é€‰æ‹©
        function initializeKnowledgeSelection() {
            knowledgeGrid.innerHTML = '';
            knowledgePoints.forEach(point => {
                const card = document.createElement('div');
                card.className = 'knowledge-card';
                card.setAttribute('data-id', point.id);
                card.innerHTML = `
                    <div class="knowledge-card-header">
                        <div class="knowledge-card-checkbox"></div>
                        <div class="knowledge-card-name">${point.name}</div>
                    </div>
                    <div class="knowledge-card-concepts">${point.concepts.join('ï¼Œ')}</div>
                `;
                card.addEventListener('click', () => toggleKnowledgeCard(card));
                knowledgeGrid.appendChild(card);
            });
        }
        
        // åˆ‡æ¢çŸ¥è¯†ç‚¹å¡ç‰‡é€‰æ‹©çŠ¶æ€
        function toggleKnowledgeCard(card) {
            card.classList.toggle('selected');
        }
        
        // è·å–é€‰ä¸­çš„çŸ¥è¯†ç‚¹
        function getSelectedKnowledgePoints() {
            const selected = [];
            document.querySelectorAll('.knowledge-card.selected').forEach(card => {
                const id = parseInt(card.getAttribute('data-id'));
                const point = knowledgePoints.find(p => p.id === id);
                if (point) selected.push(point);
            });
            return selected;
        }
        
        // å…¨é€‰çŸ¥è¯†ç‚¹
        function selectAllKnowledge() {
            document.querySelectorAll('.knowledge-card').forEach(card => {
                card.classList.add('selected');
            });
        }
        
        // å…¨ä¸é€‰çŸ¥è¯†ç‚¹
        function deselectAllKnowledge() {
            document.querySelectorAll('.knowledge-card').forEach(card => {
                card.classList.remove('selected');
            });
        }
        
        // è·å–é€‰å®šçŸ¥è¯†ç‚¹ä¸­çš„æ‰€æœ‰æ¦‚å¿µå¯¹
        function getConceptPairsFromSelectedKnowledge() {
            const selectedPoints = gameState.selectedKnowledgePoints;
            let conceptPairs = [];
            
            selectedPoints.forEach(point => {
                point.concepts.forEach(conceptPair => {
                    const [chemist, undercover] = conceptPair.split('ã€');
                    conceptPairs.push({ chemist, undercover });
                });
            });
            
            return conceptPairs;
        }
        
        // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
        function updateStatus(text, isThinking = false) {
            statusText.textContent = text;
            if (isThinking) {
                statusDot.classList.add('thinking');
            } else {
                statusDot.classList.remove('thinking');
            }
        }
        
        // æ›´æ–°ç©å®¶å¡ç‰‡çŠ¶æ€
        function updatePlayerCards() {
            gameState.players.forEach((player, index) => {
                const card = document.getElementById(`player${index+1}`);
                const statusEl = card.querySelector('.player-status');
                
                statusEl.textContent = player.status;
                
                // ç§»é™¤æ‰€æœ‰çŠ¶æ€ç±»
                card.classList.remove('active', 'voting', 'voted', 'eliminated', 'tie', 'unavailable');
                
                // æ·»åŠ é€‚å½“çš„çŠ¶æ€ç±»
                if (!player.eliminated && index === gameState.currentPlayer && 
                    (gameState.gamePhase === 'describing' || gameState.gamePhase === 'tie-describing')) {
                    card.classList.add('active');
                }
                
                if (!player.eliminated && 
                    (gameState.gamePhase === 'voting' || gameState.gamePhase === 'tie-voting') && 
                    index !== 0) {
                    card.classList.add('voting');
                }
                
                if (player.eliminated) {
                    card.classList.add('eliminated');
                    card.classList.add('unavailable');
                }
                
                // å¦‚æœæ˜¯å¹³ç¥¨ç©å®¶ä¸”æœªè¢«æ·˜æ±°ï¼Œæ·»åŠ ç‰¹æ®Šæ ·å¼
                if (!player.eliminated && gameState.tiePlayers.includes(index)) {
                    card.classList.add('tie');
                }
                
                // æ›´æ–°æŠ•ç¥¨æŒ‡ç¤ºå™¨
                const existingIndicator = card.querySelector('.vote-indicator');
                if (existingIndicator) {
                    card.removeChild(existingIndicator);
                }
                
                if (player.votes > 0) {
                    const voteIndicator = document.createElement('div');
                    voteIndicator.className = 'vote-indicator';
                    voteIndicator.textContent = player.votes;
                    card.appendChild(voteIndicator);
                }
            });
            
            // åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šï¼Œå¦‚æœæ˜¯æŠ•ç¥¨é˜¶æ®µï¼Œè‡ªåŠ¨å±•å¼€æŠ•ç¥¨å¡ç‰‡
            if (gameState.isMobile && (gameState.gamePhase === 'voting' || gameState.gamePhase === 'tie-voting')) {
                expandVotingCards();
            }
        }
        
        // å±•å¼€æŠ•ç¥¨å¡ç‰‡
        function expandVotingCards() {
            playerCards.classList.add('expanded');
            votingToggleIcon.textContent = 'ğŸ‘¥';
            votingToggleText.textContent = 'éšè—ç©å®¶å¡ç‰‡';
        }
        
        // æŠ˜å æŠ•ç¥¨å¡ç‰‡
        function collapseVotingCards() {
            playerCards.classList.remove('expanded');
            votingToggleIcon.textContent = 'ğŸ‘¥';
            votingToggleText.textContent = 'æ˜¾ç¤ºç©å®¶å¡ç‰‡';
        }
        
        // åˆ‡æ¢æŠ•ç¥¨å¡ç‰‡æ˜¾ç¤ºçŠ¶æ€
        function toggleVotingCards() {
            if (playerCards.classList.contains('expanded')) {
                collapseVotingCards();
            } else {
                expandVotingCards();
            }
        }
        
        // å°†æ¶ˆæ¯æ·»åŠ åˆ°æ¸¸æˆæ—¥å¿—
        function addMessage(sender, message, type) {
            const messageElement = document.createElement('div');
            messageElement.className = `message ${type}-message`;
            
            let senderText = sender;
            if (type === 'ai') senderText = 'AIä¸»æŒäºº';
            else if (type === 'user') senderText = gameState.players[0].name;
            
            messageElement.innerHTML = `<strong>${senderText}:</strong> ${message}`;
            gameLog.appendChild(messageElement);
            
            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            gameLog.scrollTop = gameLog.scrollHeight;
            
            return messageElement;
        }
        
        // æ·»åŠ ç³»ç»Ÿæç¤ºæ¶ˆæ¯
        function addSystemMessage(message) {
            const messageElement = document.createElement('div');
            messageElement.className = `message system-message`;
            messageElement.innerHTML = `${message}`;
            gameLog.appendChild(messageElement);
            
            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            gameLog.scrollTop = gameLog.scrollHeight;
            
            return messageElement;
        }
        
        // æ·»åŠ ç©å®¶æ¶ˆæ¯
        function addPlayerMessage(playerName, message) {
            const messageElement = document.createElement('div');
            messageElement.className = `message player-message`;
            messageElement.innerHTML = `<strong>${playerName}:</strong> ${message}`;
            gameLog.appendChild(messageElement);
            
            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            gameLog.scrollTop = gameLog.scrollHeight;
            
            return messageElement;
        }
        
        // æ·»åŠ é”™è¯¯æ¶ˆæ¯
        function addErrorMessage(message) {
            const messageElement = document.createElement('div');
            messageElement.className = `message error-message`;
            messageElement.innerHTML = `<strong>âš ï¸ é”™è¯¯:</strong> ${message}`;
            gameLog.appendChild(messageElement);
            
            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            gameLog.scrollTop = gameLog.scrollHeight;
            
            return messageElement;
        }
        
        // éªŒè¯ç”¨æˆ·æè¿°
        function validateDescription(description, concept) {
            // æ£€æŸ¥é•¿åº¦
            if (description.length < 1) {
                return { isValid: false, error: "æè¿°ä¸èƒ½ä¸ºç©º" };
            }
            
            if (description.length > 100) {
                return { isValid: false, error: "æè¿°ä¸èƒ½è¶…è¿‡100ä¸ªå­—ç¬¦" };
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«å®Œæ•´çš„æ¦‚å¿µè¯
            if (description.includes(concept)) {
                return { 
                    isValid: false, 
                    error: `æè¿°ä¸­ä¸èƒ½ç›´æ¥åŒ…å«å®Œæ•´çš„æ¦‚å¿µè¯"${concept}"` 
                };
            }
            
            // æ£€æŸ¥æ•æ„Ÿè¯
            const sensitiveWords = ['å§åº•', 'åŒ–å­¦å®¶', 'æŠ•ç¥¨', 'æ·˜æ±°', 'æ¸¸æˆ'];
            const containsSensitiveWord = sensitiveWords.some(word => 
                description.includes(word)
            );
            
            if (containsSensitiveWord) {
                return { 
                    isValid: false, 
                    error: "æè¿°ä¸­ä¸èƒ½åŒ…å«æ¸¸æˆç›¸å…³çš„æ•æ„Ÿè¯" 
                };
            }
            
            return { isValid: true };
        }
        
        // è°ƒç”¨DeepSeek APIçš„é€šç”¨å‡½æ•°
        async function callDeepSeekAPI(prompt, apiKey, temperature = 0.7, maxTokens = 100) {
            try {
                const response = await fetch(API_BASE_URL, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: "deepseek-chat",
                        messages: [{ role: "user", content: prompt }],
                        temperature: temperature,
                        max_tokens: maxTokens,
                        stream: false
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status}`);
                }
                
                const data = await response.json();
                return data.choices[0].message.content.trim();
            } catch (error) {
                console.error('APIè°ƒç”¨é”™è¯¯:', error);
                throw error;
            }
        }
        
        // ç”ŸæˆçŸ¥è¯†ç‚¹æ€»ç»“
        async function generateKnowledgeSummary(chemistConcept, undercoverConcept) {
            const prompt = `è¯·ç®€è¦æ€»ç»“ä»¥ä¸‹ä¸¤ä¸ªåŒ–å­¦æ¦‚å¿µï¼šã€${chemistConcept}ã€‘å’Œã€${undercoverConcept}ã€‘ã€‚æ€»ç»“åˆ†ä¸ºä¸‰éƒ¨åˆ†ï¼š
1. ä¸¤ä¸ªæ¦‚å¿µçš„å®šä¹‰å’Œå®ä¾‹
2. ä¸¤ä¸ªæ¦‚å¿µçš„åŒºåˆ«
3. ç®€è¦æ€»ç»“

è¯·æŒ‰ç…§ä»¥ä¸‹æ ¼å¼æä¾›æ€»ç»“ï¼š
å®šä¹‰å’Œå®ä¾‹
ã€${chemistConcept}ã€‘çš„å®šä¹‰å’Œå®ä¾‹ï¼š[å†…å®¹]
ã€${undercoverConcept}ã€‘çš„å®šä¹‰å’Œå®ä¾‹ï¼š[å†…å®¹]

æ¦‚å¿µåŒºåˆ«
ã€${chemistConcept}ã€‘å’Œã€${undercoverConcept}ã€‘çš„åŒºåˆ«ï¼š[å†…å®¹]

ç®€è¦æ€»ç»“
[å†…å®¹]

æ³¨æ„ï¼šä¸è¦ä½¿ç”¨ä»»ä½•åŠ ç²—æˆ–å…¶ä»–ç‰¹æ®Šæ ‡è®°ï¼Œä»…å°†ä¸¤ä¸ªæ¦‚å¿µç”¨ã€ã€‘æ ‡æ³¨ã€‚`;
            
            try {
                const summary = await callDeepSeekAPI(prompt, CONFIG_DATA.a, 0.5, 800);
                
                let formattedSummary = summary;
                if (summary.includes("ç¬¬äºŒéƒ¨åˆ†ï¼š")) {
                    formattedSummary = summary.replace("ç¬¬äºŒéƒ¨åˆ†ï¼š", "\n\nç¬¬äºŒéƒ¨åˆ†ï¼š");
                }
                if (summary.includes("ç¬¬ä¸‰éƒ¨åˆ†ï¼š")) {
                    formattedSummary = formattedSummary.replace("ç¬¬ä¸‰éƒ¨åˆ†ï¼š", "\n\nç¬¬ä¸‰éƒ¨åˆ†ï¼š");
                }
                
                gameState.knowledgeSummary = formattedSummary;
                
                console.log("çŸ¥è¯†ç‚¹æ€»ç»“å·²ç”Ÿæˆå¹¶ä¿å­˜");
                return formattedSummary;
                
            } catch (error) {
                console.error('çŸ¥è¯†ç‚¹æ€»ç»“å¤±è´¥:', error);
                const fallbackSummary = `ç¬¬ä¸€éƒ¨åˆ†ï¼šå®šä¹‰å’Œå®ä¾‹
ã€${chemistConcept}ã€‘çš„å®šä¹‰å’Œå®ä¾‹ï¼šè¿™æ˜¯ä¸€ä¸ªé‡è¦çš„åŒ–å­¦æ¦‚å¿µï¼Œåœ¨åŒ–å­¦å­¦ä¹ ä¸­å æœ‰é‡è¦åœ°ä½ã€‚
ã€${undercoverConcept}ã€‘çš„å®šä¹‰å’Œå®ä¾‹ï¼šè¿™ä¹Ÿæ˜¯ä¸€ä¸ªé‡è¦çš„åŒ–å­¦æ¦‚å¿µï¼Œä¸ã€${chemistConcept}ã€‘å¯†åˆ‡ç›¸å…³ã€‚

ç¬¬äºŒéƒ¨åˆ†ï¼šæ¦‚å¿µåŒºåˆ«
ã€${chemistConcept}ã€‘å’Œã€${undercoverConcept}ã€‘çš„åŒºåˆ«ï¼šè¿™ä¸¤ä¸ªæ¦‚å¿µåœ¨å®šä¹‰ã€æ€§è´¨å’Œåº”ç”¨ä¸Šæœ‰æ‰€ä¸åŒã€‚

ç¬¬ä¸‰éƒ¨åˆ†ï¼šç®€è¦æ€»ç»“
è¿™ä¸¤ä¸ªæ¦‚å¿µéƒ½æ˜¯åŒ–å­¦å­¦ä¹ ä¸­çš„é‡è¦å†…å®¹ï¼Œéœ€è¦è®¤çœŸç†è§£å’ŒåŒºåˆ†ã€‚`;
                
                gameState.knowledgeSummary = fallbackSummary;
                console.log("çŸ¥è¯†ç‚¹æ€»ç»“å·²ç”Ÿæˆå¹¶ä¿å­˜");
                return fallbackSummary;
            }
        }
        
        // æ˜¾ç¤ºçŸ¥è¯†ç‚¹æ€»ç»“
        function showKnowledgeSummary() {
            return new Promise((resolve) => {
                if (gameState.knowledgeSummary) {
                    addMessage("AIä¸»æŒäºº", gameState.knowledgeSummary, "ai");
                    
                    setTimeout(() => {
                        resolve();
                    }, 3000);
                } else {
                    resolve();
                }
            });
        }
        
        // AIç©å®¶æè¿°æç¤ºè¯
        const aiPlayerPrompt = (playerIndex, playerName, concept, previousDescriptions) => {
            let prompt = `ä½ ç°åœ¨æ˜¯åŒ–å­¦å§åº•æ¸¸æˆä¸­çš„ç©å®¶"${playerName}"ã€‚
ä½ çš„åŒ–å­¦æ¦‚å¿µæ˜¯"${concept}"ã€‚

æ¸¸æˆè§„åˆ™ï¼š
1. ç”¨ä¸€å¥è¯æè¿°ä½ çš„æ¦‚å¿µï¼Œä¸èƒ½ç›´æ¥è¯´å‡ºå®Œæ•´çš„æ¦‚å¿µåç§°
2. æè¿°è¦å‡†ç¡®ã€ç§‘å­¦ï¼Œä½†ä¹Ÿè¦æœ‰è¿·æƒ‘æ€§
3. ç‰¹åˆ«é‡è¦ï¼šä½ çš„æè¿°å¿…é¡»ä¸å…¶ä»–ç©å®¶çš„æè¿°ä¸åŒï¼Œé¿å…ä½¿ç”¨ç›¸ä¼¼çš„è¡¨è¿°æˆ–è§’åº¦`;

            if (playerIndex === 1) {
                prompt += `
4. ä½ çš„æè¿°åº”è¯¥ä¾§é‡äºè¿™ä¸ªæ¦‚å¿µåœ¨æ•™æä¸Šæ¶‰åŠåˆ°çš„çŸ¥è¯†ç‚¹`;
            } else if (playerIndex === 2) {
                prompt += `
4. ä½ çš„æè¿°åº”è¯¥ä¾§é‡äºè¿™ä¸ªæ¦‚å¿µåœ¨ç”Ÿæ´»ä¸­çš„ç”¨é€”`;
            } else if (playerIndex === 3) {
                prompt += `
4. ä½ çš„æè¿°åº”è¯¥ä¾§é‡äºæ•™æä¸Šå¯¹è¿™ä¸ªæ¦‚å¿µçš„å®šä¹‰`;
            }

            if (previousDescriptions.length > 0) {
                prompt += `

ä»¥ä¸‹æ˜¯å…¶ä»–ç©å®¶çš„æè¿°ï¼š
${previousDescriptions.map(desc => `- ${desc.player}: ${desc.description}`).join('\n')}

è¯·ç¡®ä¿ä½ çš„æè¿°ä¸ä¸Šè¿°å†…å®¹ä¸é‡å¤ã€ä¸ç›¸ä¼¼ã€‚
`;
            }

            prompt += `

è¯·æ ¹æ®ä½ çš„æ¦‚å¿µï¼Œæä¾›ä¸€å¥ç‹¬ç‰¹çš„æè¿°ã€‚åªè¾“å‡ºæè¿°å†…å®¹ï¼Œä¸è¦è¾“å‡ºä»»ä½•å…¶ä»–æ–‡å­—ã€‚`;

            return prompt;
        };
        
        // ç”ŸæˆAIç©å®¶æè¿°
        async function generateAIPlayerDescription(playerIndex) {
            const player = gameState.players[playerIndex];
            
            if (player.eliminated) {
                player.status = "å·²æ·˜æ±°ï¼ˆè§‚æˆ˜ä¸­ï¼‰";
                updatePlayerCards();
                return null;
            }
            
            updateStatus(`${player.name}æ€è€ƒä¸­...`, true);
            gameState.currentPlayer = playerIndex;
            player.status = "æè¿°ä¸­";
            updatePlayerCards();
            
            const prompt = aiPlayerPrompt(
                playerIndex,
                player.name, 
                player.concept,
                playerDescriptions
            );
            
            try {
                const apiKey = getApiKeyForPlayer(playerIndex);
                let description = await callDeepSeekAPI(prompt, apiKey, 0.8, 100);
                
                description = description.replace(/^["']|["']$/g, '');
                
                addPlayerMessage(player.name, description);
                
                playerDescriptions.push({
                    player: player.name,
                    description: description
                });
                
                player.status = "å·²å®Œæˆæè¿°";
                updatePlayerCards();
                
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                return description;
                
            } catch (error) {
                console.error('é”™è¯¯:', error);
                addMessage("AIä¸»æŒäºº", `${player.name}çš„æè¿°ç”Ÿæˆå¤±è´¥: ${error.message}`, "ai");
                player.status = "æè¿°å¤±è´¥";
                updatePlayerCards();
                
                if (!gameState.players[0].eliminated) {
                    enableInput();
                }
                return null;
            }
        }
        
        // è·å–ç©å®¶å¯¹åº”çš„APIå¯†é’¥
        function getApiKeyForPlayer(playerIndex) {
            switch(playerIndex) {
                case 0: return CONFIG_DATA.a;
                case 1: return CONFIG_DATA.b;
                case 2: return CONFIG_DATA.c;
                case 3: return CONFIG_DATA.d;
                default: return CONFIG_DATA.a;
            }
        }
        
        // ç»§ç»­ä¸‹ä¸€ä¸ªAIç©å®¶çš„æè¿°
        async function continueAIPlayerDescriptions() {
            const activeAIPlayers = [];
            for (let i = 1; i <= 3; i++) {
                if (!gameState.players[i].eliminated) {
                    activeAIPlayers.push(i);
                }
            }
            
            for (const playerIndex of activeAIPlayers) {
                if (gameState.players[playerIndex].eliminated) {
                    gameState.players[playerIndex].status = "å·²æ·˜æ±°ï¼ˆè§‚æˆ˜ä¸­ï¼‰";
                    updatePlayerCards();
                    continue;
                }
                
                await generateAIPlayerDescription(playerIndex);
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            startVotingPhase();
        }
        
        // å¼€å§‹æŠ•ç¥¨é˜¶æ®µ
        function startVotingPhase() {
            gameState.gamePhase = 'voting';
            // åˆå§‹åŒ–æŠ•ç¥¨è®°å½•
            gameState.currentVoteRecords = [];
            
            if (gameState.players[0].eliminated) {
                gameState.players[0].status = "å·²æ·˜æ±°ï¼ˆè§‚æˆ˜ä¸­ï¼‰";
                updateStatus("ä½ å·²è¢«æ·˜æ±°ï¼Œæ­£åœ¨è§‚æˆ˜");
                performAIVotes();
            } else {
                gameState.currentPlayer = 0;
                gameState.players[0].status = "è¯·æŠ•ç¥¨";
                updateStatus("è¯·ç‚¹å‡»ç©å®¶å¡ç‰‡è¿›è¡ŒæŠ•ç¥¨");
                setupVotingEventListeners();
            }
            
            updatePlayerCards();
            
            addSystemMessage("æ‰€æœ‰ç©å®¶å·²å®Œæˆæè¿°ï¼ç°åœ¨å¼€å§‹æŠ•ç¥¨ï¼Œè¯·é€‰å‡ºä½ è®¤ä¸ºçš„å§åº•ã€‚è¢«æ·˜æ±°çš„ç©å®¶å°†è¿›å…¥è§‚æˆ˜çŠ¶æ€ã€‚");
        }
        
        // è®¾ç½®æŠ•ç¥¨äº‹ä»¶ç›‘å¬å™¨
        function setupVotingEventListeners() {
            removeVotingEventListeners();
            
            document.querySelectorAll('.player-card').forEach(card => {
                const playerIndex = parseInt(card.getAttribute('data-player-index'));
                if (playerIndex !== 0 && !gameState.players[playerIndex].eliminated) {
                    card.style.cursor = 'pointer';
                    card.addEventListener('click', handleVote);
                } else {
                    card.classList.add('unavailable');
                    card.style.cursor = 'not-allowed';
                }
            });
        }
        
        // ç§»é™¤æŠ•ç¥¨äº‹ä»¶ç›‘å¬å™¨
        function removeVotingEventListeners() {
            document.querySelectorAll('.player-card').forEach(card => {
                card.removeEventListener('click', handleVote);
                card.removeEventListener('click', handleTieVote);
            });
        }
        
        // å¤„ç†æŠ•ç¥¨
        function handleVote(event) {
            if (gameState.players[0].eliminated) {
                addErrorMessage("ä½ å·²è¢«æ·˜æ±°ï¼Œä¸èƒ½å‚ä¸æŠ•ç¥¨");
                return;
            }
            
            if (gameState.gamePhase !== 'voting' || gameState.userVoted) return;
            
            const card = event.currentTarget;
            const playerIndex = parseInt(card.getAttribute('data-player-index'));
            
            if (playerIndex === 0 || gameState.players[playerIndex].eliminated) {
                addErrorMessage("ä¸èƒ½æŠ•ç¥¨ç»™è‡ªå·±æˆ–å·²è¢«æ·˜æ±°çš„ç©å®¶");
                return;
            }
            
            gameState.players[playerIndex].votes++;
            gameState.userVoted = true;
            
            updatePlayerCards();
            
            // è®°å½•æŠ•ç¥¨ä¿¡æ¯ï¼Œä½†ä¸ç«‹å³æ˜¾ç¤º
            gameState.currentVoteRecords.push(`${gameState.players[0].name} æŠ•ç¥¨ç»™äº† ${gameState.players[playerIndex].name}`);
            
            removeVotingEventListeners();
            
            performAIVotes();
        }
        
        // AIæŠ•ç¥¨æç¤ºè¯
        const aiVotePrompt = (playerIndex, playerDescriptions, activePlayerIndices) => {
            const playerMapping = activePlayerIndices.map(idx => 
                `player${idx} å¯¹åº”ç©å®¶: ${gameState.players[idx].name}`
            ).join('\n');
            
            const formattedDescriptions = playerDescriptions.map(desc => {
                const playerIdx = gameState.players.findIndex(p => p.name === desc.player);
                return `- player${playerIdx}: ${desc.description}`;
            }).join('\n');
            
            return `ä½ ç°åœ¨æ˜¯åŒ–å­¦å§åº•æ¸¸æˆä¸­çš„ç©å®¶ï¼Œä½ çš„ç¼–å·æ˜¯player${playerIndex}ã€‚

ç©å®¶ç¼–å·ä¸åç§°å¯¹åº”å…³ç³»:
${playerMapping}

å½“å‰æ´»è·ƒç©å®¶ç¼–å·: ${activePlayerIndices.map(idx => `player${idx}`).join('ã€')}

ä»¥ä¸‹æ˜¯æ‰€æœ‰ç©å®¶çš„æè¿°ï¼ˆä½¿ç”¨playerç¼–å·æ ‡è¯†ï¼‰ï¼š
${formattedDescriptions}

è¯·æ ¹æ®è¿™äº›æè¿°ï¼Œä»æ´»è·ƒç©å®¶ä¸­æŠ•ç¥¨é€‰å‡ºä½ è®¤ä¸ºçš„å§åº•ã€‚åªè¾“å‡ºå§åº•çš„playerç¼–å·ï¼ˆå¦‚"player0"ã€"player1"ç­‰ï¼‰ï¼Œä¸è¦è¾“å‡ºä»»ä½•å…¶ä»–æ–‡å­—ã€‚`;
        };
        
        // æ‰§è¡ŒAIæŠ•ç¥¨
        async function performAIVotes() {
            updateStatus("AIç©å®¶æŠ•ç¥¨ä¸­...", true);
            
            gameState.aiVotes = [];
            
            const activePlayerIndices = gameState.players
                .map((p, idx) => ({idx, p}))
                .filter(({p}) => !p.eliminated)
                .map(({idx}) => idx);
            
            for (let i = 1; i <= 3; i++) {
                if (!gameState.players[i].eliminated) {
                    await generateAIVote(i, activePlayerIndices);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                } else {
                    gameState.players[i].status = "å·²æ·˜æ±°ï¼ˆè§‚æˆ˜ä¸­ï¼‰";
                }
            }
            
            updatePlayerCards();
            
            calculateVoteResult();
        }
        
        // ç”ŸæˆAIæŠ•ç¥¨
        async function generateAIVote(playerIndex, activePlayerIndices) {
            const player = gameState.players[playerIndex];
            
            if (player.eliminated) {
                return;
            }
            
            const prompt = aiVotePrompt(
                playerIndex,
                playerDescriptions,
                activePlayerIndices
            );
            
            try {
                const apiKey = getApiKeyForPlayer(playerIndex);
                let vote = await callDeepSeekAPI(prompt, apiKey, 0.7, 50);
                
                let votedPlayerIndex = -1;
                const match = vote.match(/player(\d+)/);
                if (match) {
                    votedPlayerIndex = parseInt(match[1]);
                }
                
                if (votedPlayerIndex === -1 || 
                    votedPlayerIndex === playerIndex || 
                    !activePlayerIndices.includes(votedPlayerIndex)) {
                    const availablePlayers = activePlayerIndices.filter(idx => idx !== playerIndex);
                    
                    if (availablePlayers.length > 0) {
                        votedPlayerIndex = availablePlayers[Math.floor(Math.random() * availablePlayers.length)];
                    } else {
                        votedPlayerIndex = (playerIndex + 1) % 4;
                    }
                }
                
                gameState.players[votedPlayerIndex].votes++;
                gameState.aiVotes.push({
                    voter: player.name,
                    voted: gameState.players[votedPlayerIndex].name
                });
                
                // è®°å½•æŠ•ç¥¨ä¿¡æ¯ï¼Œä½†ä¸ç«‹å³æ˜¾ç¤º
                gameState.currentVoteRecords.push(`${player.name} æŠ•ç¥¨ç»™äº† ${gameState.players[votedPlayerIndex].name}`);
                
                updatePlayerCards();
                
            } catch (error) {
                console.error('é”™è¯¯:', error);
                const availablePlayers = activePlayerIndices.filter(idx => idx !== playerIndex);
                
                if (availablePlayers.length > 0) {
                    const votedPlayerIndex = availablePlayers[Math.floor(Math.random() * availablePlayers.length)];
                    gameState.players[votedPlayerIndex].votes++;
                    gameState.aiVotes.push({
                        voter: player.name,
                        voted: gameState.players[votedPlayerIndex].name
                    });
                    
                    // è®°å½•æŠ•ç¥¨ä¿¡æ¯ï¼Œä½†ä¸ç«‹å³æ˜¾ç¤º
                    gameState.currentVoteRecords.push(`${player.name} æŠ•ç¥¨ç»™äº† ${gameState.players[votedPlayerIndex].name}`);
                    updatePlayerCards();
                }
            }
        }
        
        // è®¡ç®—æŠ•ç¥¨ç»“æœ
        function calculateVoteResult() {
            updateStatus("è®¡ç®—æŠ•ç¥¨ç»“æœ...", true);
            
            const activePlayers = gameState.players
                .map((player, index) => ({ 
                    index, 
                    name: player.name,
                    votes: player.votes 
                }))
                .filter(({ index }) => !gameState.players[index].eliminated);
            
            if (activePlayers.length === 0) {
                addErrorMessage("æ²¡æœ‰æ´»è·ƒç©å®¶ï¼Œæ— æ³•è®¡ç®—æŠ•ç¥¨ç»“æœ");
                return;
            }
            
            const maxVotes = Math.max(...activePlayers.map(p => p.votes));
            
            const playersWithMaxVotes = activePlayers.filter(p => p.votes === maxVotes);
            
            if (playersWithMaxVotes.length > 1) {
                const tiePlayerIndices = playersWithMaxVotes.map(p => p.index);
                const tiePlayerVotes = playersWithMaxVotes.map(p => p.votes);
                
                handleSpecificTieCase(tiePlayerIndices, tiePlayerVotes, maxVotes);
            } else {
                // é‡ç½®å¹³ç¥¨è®¡æ•°ï¼Œå› ä¸ºè¿™ä¸æ˜¯å¹³ç¥¨
                gameState.tieCount = 0;
                setTimeout(() => {
                    // åˆå¹¶æŠ•ç¥¨ä¿¡æ¯å’Œæ·˜æ±°ä¿¡æ¯åˆ°ä¸€æ¡ç³»ç»Ÿæç¤º
                    const voteSummary = gameState.currentVoteRecords.join('ï¼Œ');
                    const eliminationMessage = `${voteSummary}ï¼›${gameState.players[playersWithMaxVotes[0].index].name} è·å¾—${maxVotes}ç¥¨ï¼Œè¢«æ·˜æ±°ï¼`;
                    addSystemMessage(eliminationMessage);
                    
                    eliminatePlayer(playersWithMaxVotes[0].index);
                }, 1000);
            }
        }
        
        // åˆ†æƒ…å†µå¤„ç†å„ç§å¹³ç¥¨æƒ…å†µ
        function handleSpecificTieCase(tiePlayerIndices, tiePlayerVotes, maxVotes) {
            setTimeout(() => {
                const tiePlayerNames = tiePlayerIndices.map(idx => gameState.players[idx].name).join('ã€');
                
                // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§å¹³ç¥¨æ¬¡æ•°
                gameState.tieCount++; // å¢åŠ å¹³ç¥¨è®¡æ•°
                
                // å¦‚æœè¿ç»­å¹³ç¥¨3æ¬¡ï¼Œéšæœºæ·˜æ±°ä¸€åå¹³ç¥¨é€‰æ‰‹
                if (gameState.tieCount >= 3) {
                    handleMaxTieRounds(tiePlayerIndices);
                    return;
                }
                
                // ç¬¬ä¸€å›åˆå¹³ç¥¨æƒ…å†µå¤„ç†
                if (gameState.tieCount === 1) {
                    // æƒ…å†µ1: æ‰€æœ‰4åç©å®¶å„å¾—1ç¥¨
                    if (tiePlayerIndices.length === 4 && maxVotes === 1) {
                        // åˆå¹¶æŠ•ç¥¨ä¿¡æ¯å’Œæ·˜æ±°ä¿¡æ¯åˆ°ä¸€æ¡ç³»ç»Ÿæç¤º
                        const voteSummary = gameState.currentVoteRecords.join('ï¼Œ');
                        const tieMessage = `${voteSummary}ï¼›${tiePlayerNames} å„è·å¾—1ç¥¨ï¼Œå¹³ç¥¨ï¼`;
                        addSystemMessage(tieMessage);
                        
                        handleFourPlayersTie(tiePlayerIndices);
                    }
                    // æƒ…å†µ2: ä¸¤åç©å®¶å„å¾—2ç¥¨ï¼ˆ7ç§ç»„åˆï¼‰
                    else if (tiePlayerIndices.length === 2 && maxVotes === 2) {
                        // åˆå¹¶æŠ•ç¥¨ä¿¡æ¯å’Œæ·˜æ±°ä¿¡æ¯åˆ°ä¸€æ¡ç³»ç»Ÿæç¤º
                        const voteSummary = gameState.currentVoteRecords.join('ï¼Œ');
                        const tieMessage = `${voteSummary}ï¼›${tiePlayerNames} å„è·å¾—2ç¥¨ï¼Œå¹³ç¥¨ï¼`;
                        addSystemMessage(tieMessage);
                        
                        handleTwoPlayersTie(tiePlayerIndices);
                    }
                    // å…¶ä»–æœªæ˜ç¡®åˆ—å‡ºçš„ç¬¬ä¸€å›åˆå¹³ç¥¨æƒ…å†µ
                    else {
                        // åˆå¹¶æŠ•ç¥¨ä¿¡æ¯å’Œæ·˜æ±°ä¿¡æ¯åˆ°ä¸€æ¡ç³»ç»Ÿæç¤º
                        const voteSummary = gameState.currentVoteRecords.join('ï¼Œ');
                        const tieMessage = `${voteSummary}ï¼›${tiePlayerNames} éƒ½è·å¾—${maxVotes}ç¥¨ï¼Œå¹³ç¥¨ï¼`;
                        addSystemMessage(tieMessage);
                        
                        handleGenericTie(tiePlayerIndices);
                    }
                }
                // ç¬¬äºŒå›åˆå¹³ç¥¨æƒ…å†µå¤„ç†
                else if (gameState.tieCount === 2) {
                    // æƒ…å†µ: ä¸‰åç©å®¶å„å¾—1ç¥¨ï¼ˆ4ç§ç»„åˆï¼‰
                    if (tiePlayerIndices.length === 3 && maxVotes === 1) {
                        // åˆå¹¶æŠ•ç¥¨ä¿¡æ¯å’Œæ·˜æ±°ä¿¡æ¯åˆ°ä¸€æ¡ç³»ç»Ÿæç¤º
                        const voteSummary = gameState.currentVoteRecords.join('ï¼Œ');
                        const tieMessage = `${voteSummary}ï¼›${tiePlayerNames} å„è·å¾—1ç¥¨ï¼Œå¹³ç¥¨ï¼`;
                        addSystemMessage(tieMessage);
                        
                        handleThreePlayersTie(tiePlayerIndices);
                    }
                    // å…¶ä»–ç¬¬äºŒå›åˆå¹³ç¥¨æƒ…å†µ
                    else {
                        // åˆå¹¶æŠ•ç¥¨ä¿¡æ¯å’Œæ·˜æ±°ä¿¡æ¯åˆ°ä¸€æ¡ç³»ç»Ÿæç¤º
                        const voteSummary = gameState.currentVoteRecords.join('ï¼Œ');
                        const tieMessage = `${voteSummary}ï¼›${tiePlayerNames} éƒ½è·å¾—${maxVotes}ç¥¨ï¼Œå¹³ç¥¨ï¼`;
                        addSystemMessage(tieMessage);
                        
                        handleGenericTie(tiePlayerIndices);
                    }
                }
            }, 1000);
        }
        
        // å¤„ç†4åç©å®¶å„å¾—1ç¥¨çš„å¹³ç¥¨æƒ…å†µ
        function handleFourPlayersTie(tiePlayerIndices) {
            gameState.tiePlayers = tiePlayerIndices;
            
            updatePlayerCards();
            
            addSystemMessage("æ‰€æœ‰ç©å®¶éƒ½è·å¾—äº†ç›¸åŒç¥¨æ•°ï¼Œç°åœ¨è¿›å…¥è¡¥å……å‘è¨€é˜¶æ®µã€‚");
            addSystemMessage("æ¯ä½ç©å®¶éœ€è¦è¿›è¡Œä¸€æ¬¡è¡¥å……æè¿°ï¼Œå¸®åŠ©å¤§å®¶æ›´å¥½åœ°åˆ¤æ–­èº«ä»½ã€‚");
            
            gameState.gamePhase = 'tie-describing';
            updateStatus("æ‰€æœ‰ç©å®¶è¿›è¡Œè¡¥å……æè¿°");
            
            setTimeout(() => {
                startSequentialTieDescription(tiePlayerIndices, 0);
            }, 1000);
        }
        
        // å¤„ç†2åç©å®¶å„å¾—2ç¥¨çš„å¹³ç¥¨æƒ…å†µï¼ˆ7ç§ç»„åˆï¼‰
        function handleTwoPlayersTie(tiePlayerIndices) {
            gameState.tiePlayers = tiePlayerIndices;
            
            updatePlayerCards();
            
            const playerNames = tiePlayerIndices.map(idx => gameState.players[idx].name);
            const pairDescription = `${playerNames[0]}å’Œ${playerNames[1]}`;
            
            addSystemMessage(`${pairDescription}è·å¾—ç›¸åŒç¥¨æ•°ï¼Œç°åœ¨è¿›å…¥è¡¥å……å‘è¨€é˜¶æ®µã€‚`);
            addSystemMessage(`åªæœ‰${pairDescription}éœ€è¦è¿›è¡Œè¡¥å……æè¿°ï¼Œå…¶ä»–ç©å®¶ä¿æŒæ²‰é»˜ã€‚`);
            
            gameState.gamePhase = 'tie-describing';
            updateStatus(`${pairDescription}è¿›è¡Œè¡¥å……æè¿°`);
            
            setTimeout(() => {
                startSequentialTieDescription(tiePlayerIndices, 0);
            }, 1000);
        }
        
        // å¤„ç†3åç©å®¶å„å¾—1ç¥¨çš„å¹³ç¥¨æƒ…å†µï¼ˆ4ç§ç»„åˆï¼‰
        function handleThreePlayersTie(tiePlayerIndices) {
            gameState.tiePlayers = tiePlayerIndices;
            
            updatePlayerCards();
            
            const playerNames = tiePlayerIndices.map(idx => gameState.players[idx].name);
            
            addSystemMessage("è¿™æ˜¯ç¬¬äºŒå›åˆå¹³ç¥¨ï¼Œä¸‰ä½ç©å®¶è·å¾—ç›¸åŒç¥¨æ•°ã€‚");
            addSystemMessage(`${playerNames.join('ã€')}éœ€è¦è¿›è¡Œç¬¬äºŒæ¬¡è¡¥å……æè¿°ï¼Œæ¯äººé™æ—¶æ›´çŸ­ã€‚`);
            
            gameState.gamePhase = 'tie-describing';
            updateStatus("ä¸‰ä½ç©å®¶è¿›è¡Œç¬¬äºŒæ¬¡è¡¥å……æè¿°");
            
            setTimeout(() => {
                startSequentialTieDescription(tiePlayerIndices, 0);
            }, 1000);
        }
        
        // å¤„ç†é€šç”¨å¹³ç¥¨æƒ…å†µ
        function handleGenericTie(tiePlayerIndices) {
            gameState.tiePlayers = tiePlayerIndices;
            
            updatePlayerCards();
            
            const tiePlayerNames = tiePlayerIndices.map(idx => gameState.players[idx].name).join('ã€');
            
            gameState.gamePhase = 'tie-describing';
            updateStatus("å¹³ç¥¨ç©å®¶è¿›è¡Œè¡¥å……æè¿°");
            
            setTimeout(() => {
                startSequentialTieDescription(tiePlayerIndices, 0);
            }, 1000);
        }
        
        // å¤„ç†è¾¾åˆ°æœ€å¤§å¹³ç¥¨æ¬¡æ•°çš„æƒ…å†µ - éšæœºæ·˜æ±°ä¸€åå¹³ç¥¨ç©å®¶
        function handleMaxTieRounds(tiePlayerIndices) {
            // éšæœºé€‰æ‹©ä¸€åç©å®¶æ·˜æ±°
            const randomIndex = Math.floor(Math.random() * tiePlayerIndices.length);
            const eliminatedIndex = tiePlayerIndices[randomIndex];
            
            // åˆå¹¶æŠ•ç¥¨ä¿¡æ¯å’Œæ·˜æ±°ä¿¡æ¯åˆ°ä¸€æ¡ç³»ç»Ÿæç¤º
            const voteSummary = gameState.currentVoteRecords.join('ï¼Œ');
            const eliminationMessage = `${voteSummary}ï¼›ç»è¿‡${gameState.tieCount}è½®æŠ•ç¥¨ï¼Œä»ç„¶å¹³ç¥¨ï¼Œè¾¾åˆ°æœ€å¤§é™åˆ¶ï¼Œéšæœºæ·˜æ±°ä¸€åå¹³ç¥¨ç©å®¶ï¼š${gameState.players[eliminatedIndex].name}è¢«æ·˜æ±°ï¼`;
            addSystemMessage(eliminationMessage);
            
            // é‡ç½®å¹³ç¥¨çŠ¶æ€
            gameState.tiePlayers = [];
            gameState.tieCount = 0;
            
            // å»¶è¿Ÿæ‰§è¡Œæ·˜æ±°ï¼Œè®©ç©å®¶æœ‰æ—¶é—´é˜…è¯»ä¿¡æ¯
            setTimeout(() => {
                eliminatePlayer(eliminatedIndex);
            }, 2000);
        }
        
        // æŒ‰é¡ºåºå¤„ç†å¹³ç¥¨ç©å®¶çš„è¡¥å……æè¿°
        async function startSequentialTieDescription(tiePlayerIndices, currentIndex) {
            if (currentIndex >= tiePlayerIndices.length) {
                resetVotingResults();
                startTieVotingPhase();
                return;
            }
            
            const playerIndex = tiePlayerIndices[currentIndex];
            
            if (gameState.players[playerIndex].eliminated) {
                startSequentialTieDescription(tiePlayerIndices, currentIndex + 1);
                return;
            }
            
            if (playerIndex === 0) {
                addSystemMessage(`${gameState.players[playerIndex].name}ï¼Œè¯·è¿›è¡Œè¡¥å……æè¿°ã€‚`);
                gameState.currentPlayer = playerIndex;
                gameState.players[playerIndex].status = "å‡†å¤‡è¡¥å……æè¿°";
                updateStatus("è¯·è¿›è¡Œè¡¥å……æè¿°");
                updatePlayerCards();
                enableInput();
                
                gameState.waitingForUserTieDescription = {
                    tiePlayerIndices: tiePlayerIndices,
                    nextIndex: currentIndex + 1
                };
            } 
            else {
                await generateTieDescription(playerIndex);
                startSequentialTieDescription(tiePlayerIndices, currentIndex + 1);
            }
        }
        
        // é‡ç½®æŠ•ç¥¨ç»“æœ
        function resetVotingResults() {
            gameState.players.forEach(player => {
                player.votes = 0;
            });
            
            gameState.userVoted = false;
            gameState.aiVotes = [];
            
            updatePlayerCards();
            
            addSystemMessage("æ‰€æœ‰ç©å®¶ç¥¨æ•°å·²é‡ç½®ï¼Œå‡†å¤‡è¿›å…¥é‡æ–°æŠ•ç¥¨é˜¶æ®µã€‚");
        }
        
        // ç”Ÿæˆå¹³ç¥¨ç©å®¶çš„é¢å¤–æè¿°
        async function generateTieDescription(playerIndex) {
            const player = gameState.players[playerIndex];
            
            if (player.eliminated) {
                player.status = "å·²æ·˜æ±°ï¼ˆè§‚æˆ˜ä¸­ï¼‰";
                updatePlayerCards();
                return null;
            }
            
            updateStatus(`${player.name}è¿›è¡Œè¡¥å……æè¿°...`, true);
            gameState.currentPlayer = playerIndex;
            player.status = "è¡¥å……æè¿°ä¸­";
            updatePlayerCards();
            
            const roundInfo = gameState.tieCount === 1 ? "ç¬¬ä¸€æ¬¡" : "ç¬¬äºŒæ¬¡";
            const timeInfo = gameState.tieCount === 1 ? "æ­£å¸¸æ—¶é—´" : "æ›´çŸ­æ—¶é—´";
            
            const prompt = `ç°åœ¨æ˜¯åŒ–å­¦å§åº•æ¸¸æˆçš„${roundInfo}å¹³ç¥¨è¡¥å……æè¿°é˜¶æ®µã€‚ä½ éœ€è¦åœ¨${timeInfo}å†…æä¾›è¡¥å……æè¿°ã€‚
ä½ å’Œ${gameState.tiePlayers.map(idx => gameState.players[idx].name).filter(name => name !== player.name).join('ã€')}å¾—ç¥¨ç›¸åŒã€‚

è¯·æ ¹æ®ä½ çš„æ¦‚å¿µ"${player.concept}"ï¼Œæä¾›ä¸€å¥å…¨æ–°çš„ã€ä¸ä¹‹å‰æè¿°ä¸åŒçš„è¡¥å……æè¿°ã€‚
è®°ä½ï¼š
1. ä¸èƒ½ç›´æ¥è¯´å‡ºå®Œæ•´çš„æ¦‚å¿µåç§°
2. æè¿°è¦å‡†ç¡®ä½†ä¹Ÿè¦æœ‰è¿·æƒ‘æ€§
3. å¿…é¡»ä¸æ‰€æœ‰ä¹‹å‰çš„æè¿°ï¼ˆåŒ…æ‹¬ä½ è‡ªå·±çš„ï¼‰ä¸åŒ

ä»¥ä¸‹æ˜¯æ‰€æœ‰ä¹‹å‰çš„æè¿°ï¼š
${playerDescriptions.map(desc => `- ${desc.player}: ${desc.description}`).join('\n')}

è¯·æä¾›ä¸€å¥ç‹¬ç‰¹çš„è¡¥å……æè¿°ã€‚åªè¾“å‡ºæè¿°å†…å®¹ï¼Œä¸è¦è¾“å‡ºä»»ä½•å…¶ä»–æ–‡å­—ã€‚`;
            
            try {
                const apiKey = getApiKeyForPlayer(playerIndex);
                let description = await callDeepSeekAPI(prompt, apiKey, 0.8, 100);
                
                description = description.replace(/^["']|["']$/g, '');
                
                addPlayerMessage(player.name, description);
                
                playerDescriptions.push({
                    player: player.name,
                    description: description,
                    isTieDescription: true,
                    tieRound: gameState.tieCount
                });
                
                player.status = "å·²å®Œæˆè¡¥å……æè¿°";
                updatePlayerCards();
                
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                return description;
                
            } catch (error) {
                console.error('é”™è¯¯:', error);
                addSystemMessage(`${player.name}çš„è¡¥å……æè¿°ç”Ÿæˆå¤±è´¥: ${error.message}`);
                player.status = "è¡¥å……æè¿°å¤±è´¥";
                updatePlayerCards();
                return null;
            }
        }
        
        // å¼€å§‹å¹³ç¥¨æŠ•ç¥¨é˜¶æ®µ
        function startTieVotingPhase() {
            gameState.gamePhase = 'tie-voting';
            // åˆå§‹åŒ–æŠ•ç¥¨è®°å½•
            gameState.currentVoteRecords = [];
            
            if (gameState.players[0].eliminated) {
                gameState.players[0].status = "å·²æ·˜æ±°ï¼ˆè§‚æˆ˜ä¸­ï¼‰";
                updateStatus("ä½ å·²è¢«æ·˜æ±°ï¼Œæ­£åœ¨è§‚æˆ˜");
                performAITieVotes();
            } else {
                gameState.currentPlayer = 0;
                gameState.players[0].status = "è¯·é‡æ–°æŠ•ç¥¨";
                updateStatus("è¯·ä¸ºå¹³ç¥¨ç©å®¶é‡æ–°æŠ•ç¥¨");
                setupTieVotingEventListeners();
            }
            
            updatePlayerCards();
            
            const tiePlayerNames = gameState.tiePlayers.map(idx => gameState.players[idx].name).join('ã€');
            if (gameState.tiePlayers.length === 4) {
                addSystemMessage("æ‰€æœ‰ç©å®¶å·²å®Œæˆè¡¥å……æè¿°ï¼è¯·ä»æ‰€æœ‰ç©å®¶ä¸­é‡æ–°æŠ•ç¥¨ã€‚");
            } else if (gameState.tiePlayers.length === 3) {
                addSystemMessage(`ä¸‰ä½ç©å®¶å·²å®Œæˆç¬¬äºŒæ¬¡è¡¥å……æè¿°ï¼è¯·ä»${tiePlayerNames}ä¸­é‡æ–°æŠ•ç¥¨ã€‚`);
            } else {
                addSystemMessage(`${tiePlayerNames}å·²å®Œæˆè¡¥å……æè¿°ï¼è¯·ä»ä»–ä»¬ä¸­é‡æ–°æŠ•ç¥¨ã€‚`);
            }
        }
        
        // è®¾ç½®å¹³ç¥¨æŠ•ç¥¨äº‹ä»¶ç›‘å¬å™¨
        function setupTieVotingEventListeners() {
            removeVotingEventListeners();
            
            document.querySelectorAll('.player-card').forEach(card => {
                const playerIndex = parseInt(card.getAttribute('data-player-index'));
                if (gameState.tiePlayers.includes(playerIndex) && !gameState.players[playerIndex].eliminated) {
                    card.style.cursor = 'pointer';
                    card.addEventListener('click', handleTieVote);
                    card.classList.add('voting');
                } else {
                    card.classList.add('unavailable');
                    card.style.cursor = 'not-allowed';
                }
            });
        }
        
        // å¤„ç†å¹³ç¥¨æŠ•ç¥¨
        function handleTieVote(event) {
            if (gameState.players[0].eliminated) {
                addErrorMessage("ä½ å·²è¢«æ·˜æ±°ï¼Œä¸èƒ½å‚ä¸æŠ•ç¥¨");
                return;
            }
            
            if (gameState.gamePhase !== 'tie-voting' || gameState.userVoted) return;
            
            const card = event.currentTarget;
            const playerIndex = parseInt(card.getAttribute('data-player-index'));
            
            if (!gameState.tiePlayers.includes(playerIndex) || gameState.players[playerIndex].eliminated) {
                addErrorMessage("åªèƒ½æŠ•ç¥¨ç»™å¹³ç¥¨ä¸”æœªè¢«æ·˜æ±°çš„ç©å®¶");
                return;
            }
            
            gameState.players[playerIndex].votes++;
            gameState.userVoted = true;
            
            updatePlayerCards();
            
            // è®°å½•æŠ•ç¥¨ä¿¡æ¯ï¼Œä½†ä¸ç«‹å³æ˜¾ç¤º
            gameState.currentVoteRecords.push(`${gameState.players[0].name} æŠ•ç¥¨ç»™äº† ${gameState.players[playerIndex].name}`);
            
            removeVotingEventListeners();
            
            performAITieVotes();
        }
        
        // æ‰§è¡ŒAIå¹³ç¥¨æŠ•ç¥¨
        async function performAITieVotes() {
            updateStatus("AIç©å®¶é‡æ–°æŠ•ç¥¨ä¸­...", true);
            
            gameState.aiVotes = [];
            
            const activePlayerIndices = gameState.players
                .map((p, idx) => ({idx, p}))
                .filter(({p}) => !p.eliminated)
                .map(({idx}) => idx);
            
            for (let i = 1; i <= 3; i++) {
                if (!gameState.players[i].eliminated) {
                    await generateAITieVote(i, activePlayerIndices);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                } else {
                    gameState.players[i].status = "å·²æ·˜æ±°ï¼ˆè§‚æˆ˜ä¸­ï¼‰";
                }
            }
            
            updatePlayerCards();
            
            calculateVoteResult();
        }
        
        // ç”ŸæˆAIå¹³ç¥¨æŠ•ç¥¨
        async function generateAITieVote(playerIndex, activePlayerIndices) {
            const player = gameState.players[playerIndex];
            
            if (player.eliminated) {
                return;
            }
            
            const formattedDescriptions = playerDescriptions.map(desc => {
                const playerIdx = gameState.players.findIndex(p => p.name === desc.player);
                return `- player${playerIdx}: ${desc.description}`;
            }).join('\n');
            
            const playerMapping = activePlayerIndices.map(idx => 
                `player${idx} å¯¹åº”ç©å®¶: ${gameState.players[idx].name}`
            ).join('\n');
            
            const prompt = `ç°åœ¨æ˜¯åŒ–å­¦å§åº•æ¸¸æˆçš„å¹³ç¥¨é‡æ–°æŠ•ç¥¨é˜¶æ®µã€‚ä½ æ˜¯player${playerIndex}ã€‚

ç©å®¶ç¼–å·ä¸åç§°å¯¹åº”å…³ç³»:
${playerMapping}

å½“å‰å¹³ç¥¨ç©å®¶ç¼–å·: ${gameState.tiePlayers.map(idx => `player${idx}`).join('ã€')}

ä»¥ä¸‹æ˜¯æ‰€æœ‰ç©å®¶çš„æè¿°ï¼ˆåŒ…æ‹¬è¡¥å……æè¿°ï¼‰ï¼š
${formattedDescriptions}

è¯·æ ¹æ®è¿™äº›æè¿°ï¼Œä»å¹³ç¥¨ç©å®¶ä¸­æŠ•ç¥¨é€‰å‡ºä½ è®¤ä¸ºçš„å§åº•ã€‚åªè¾“å‡ºå§åº•çš„playerç¼–å·ï¼Œä¸è¦è¾“å‡ºä»»ä½•å…¶ä»–æ–‡å­—ã€‚`;
            
            try {
                const apiKey = getApiKeyForPlayer(playerIndex);
                let vote = await callDeepSeekAPI(prompt, apiKey, 0.7, 50);
                
                let votedPlayerIndex = -1;
                const match = vote.match(/player(\d+)/);
                if (match) {
                    votedPlayerIndex = parseInt(match[1]);
                }
                
                if (votedPlayerIndex === -1 || 
                    !gameState.tiePlayers.includes(votedPlayerIndex) || 
                    gameState.players[votedPlayerIndex].eliminated) {
                    votedPlayerIndex = gameState.tiePlayers[Math.floor(Math.random() * gameState.tiePlayers.length)];
                }
                
                gameState.players[votedPlayerIndex].votes++;
                gameState.aiVotes.push({
                    voter: player.name,
                    voted: gameState.players[votedPlayerIndex].name,
                    isTieVote: true
                });
                
                // è®°å½•æŠ•ç¥¨ä¿¡æ¯ï¼Œä½†ä¸ç«‹å³æ˜¾ç¤º
                gameState.currentVoteRecords.push(`${player.name} æŠ•ç¥¨ç»™äº† ${gameState.players[votedPlayerIndex].name}`);
                
                updatePlayerCards();
                
            } catch (error) {
                console.error('é”™è¯¯:', error);
                const votedPlayerIndex = gameState.tiePlayers[Math.floor(Math.random() * gameState.tiePlayers.length)];
                gameState.players[votedPlayerIndex].votes++;
                gameState.aiVotes.push({
                    voter: player.name,
                    voted: gameState.players[votedPlayerIndex].name,
                    isTieVote: true
                });
                
                // è®°å½•æŠ•ç¥¨ä¿¡æ¯ï¼Œä½†ä¸ç«‹å³æ˜¾ç¤º
                gameState.currentVoteRecords.push(`${player.name} æŠ•ç¥¨ç»™äº† ${gameState.players[votedPlayerIndex].name}`);
                updatePlayerCards();
            }
        }
        
        // æ·˜æ±°ç©å®¶
        function eliminatePlayer(playerIndex) {
            const player = gameState.players[playerIndex];
            player.eliminated = true;
            player.status = "å·²æ·˜æ±°ï¼ˆè§‚æˆ˜ä¸­ï¼‰";
            
            gameState.tiePlayers = [];
            
            updatePlayerCards();
            
            if (playerIndex === 0) {
                disableInput();
            }
            
            checkGameEnd(playerIndex);
        }
        
        // æ­ç¤ºç”¨æˆ·è§’è‰²
        function revealUserRole() {
            if (!gameState.roleRevealed) {
                const userRole = gameState.players[0].role;
                myRole.textContent = userRole;
                myRole.className = `concept-role role-${userRole === 'åŒ–å­¦å®¶' ? 'chemist' : 'undercover'} revealed`;
                gameState.roleRevealed = true;
                
                addSystemMessage(`${gameState.players[0].name}çš„çœŸå®èº«ä»½æ˜¯ï¼š${userRole}ï¼`);
            }
        }
        
        // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
        function checkGameEnd(eliminatedPlayerIndex) {
            const eliminatedPlayer = gameState.players[eliminatedPlayerIndex];
            
            revealUserRole();
            
            // åˆ¤æ–­ç©å®¶æ˜¯å¦è·èƒœ
            let playerWon = false;
            
            if (eliminatedPlayer.role === 'å§åº•') {
                addSystemMessage(`æ­å–œï¼${eliminatedPlayer.name} æ˜¯å§åº•ï¼ŒåŒ–å­¦å®¶è·èƒœï¼`);
                gameState.gamePhase = 'ended';
                updateStatus("æ¸¸æˆç»“æŸ - åŒ–å­¦å®¶è·èƒœ");
                
                // ç©å®¶æ˜¯åŒ–å­¦å®¶ä¸”å§åº•è¢«æ·˜æ±°ï¼Œç©å®¶è·èƒœ
                playerWon = gameState.players[0].role === 'åŒ–å­¦å®¶';
                
            } else {
                const undercoverStillAlive = gameState.players.some(
                    (player, index) => index !== eliminatedPlayerIndex && 
                    !player.eliminated && 
                    player.role === 'å§åº•'
                );
                
                if (undercoverStillAlive) {
                    addSystemMessage(`${eliminatedPlayer.name} æ˜¯åŒ–å­¦å®¶ï¼Œå§åº•ä»ç„¶åœ¨æ¸¸æˆä¸­ï¼`);
                    const alivePlayers = gameState.players.filter(player => !player.eliminated);
                    if (alivePlayers.length <= 2) {
                        const undercover = gameState.players.find(player => 
                            !player.eliminated && player.role === 'å§åº•'
                        );
                        addSystemMessage(`æ¸¸æˆç»“æŸï¼${undercover.name} æ˜¯å§åº•ï¼Œå§åº•è·èƒœï¼`);
                        gameState.gamePhase = 'ended';
                        updateStatus("æ¸¸æˆç»“æŸ - å§åº•è·èƒœ");
                        
                        // ç©å®¶æ˜¯å§åº•ä¸”åšæŒåˆ°æœ€åï¼Œç©å®¶è·èƒœ
                        playerWon = gameState.players[0].role === 'å§åº•';
                        
                    } else {
                        setTimeout(() => {
                            addSystemMessage("æ¸¸æˆç»§ç»­ï¼Œè¯·å¼€å§‹æ–°ä¸€è½®æè¿°ã€‚");
                            resetForNewRound();
                        }, 2000);
                        return; // æ¸¸æˆç»§ç»­ï¼Œä¸æ˜¾ç¤ºèƒœåˆ©ç•Œé¢
                    }
                } else {
                    addSystemMessage("æ¸¸æˆç»“æŸï¼æ‰€æœ‰å§åº•å·²è¢«æ·˜æ±°ï¼ŒåŒ–å­¦å®¶è·èƒœï¼");
                    gameState.gamePhase = 'ended';
                    updateStatus("æ¸¸æˆç»“æŸ - åŒ–å­¦å®¶è·èƒœ");
                    
                    // ç©å®¶æ˜¯åŒ–å­¦å®¶ä¸”æ‰€æœ‰å§åº•è¢«æ·˜æ±°ï¼Œç©å®¶è·èƒœ
                    playerWon = gameState.players[0].role === 'åŒ–å­¦å®¶';
                }
            }
            
            // æ›´æ–°èƒœåˆ©è®¡æ•°
            updateWinCounts(playerWon);
            
            // ä¿å­˜ç©å®¶è·èƒœçŠ¶æ€
            gameState.playerWon = playerWon;
            
            // æ˜¾ç¤ºçŸ¥è¯†ç‚¹æ€»ç»“ï¼Œç„¶åæ˜¾ç¤ºèƒœåˆ©ç•Œé¢
            setTimeout(() => {
                showKnowledgeSummary().then(() => {
                    setTimeout(() => {
                        // ä¿®æ”¹ï¼šæ— è®ºèƒœè´Ÿéƒ½æ˜¾ç¤ºèƒœåˆ©ç•Œé¢
                        showVictoryScreen(playerWon);
                    }, 2000);
                });
            }, 2000);
        }
        
        // æ›´æ–°èƒœåˆ©è®¡æ•°
        function updateWinCounts(isPlayerWin) {
            if (isPlayerWin) {
                gameState.playerWins++;
            }
            
            gameState.totalRounds++;
        }
        
        // ä¿®æ”¹ï¼šæ˜¾ç¤ºèƒœåˆ©ç•Œé¢ï¼Œæ ¹æ®ç©å®¶æ˜¯å¦è·èƒœæ˜¾ç¤ºä¸åŒå†…å®¹
        function showVictoryScreen(isPlayerWin) {
            // æ›´æ–°ç»Ÿè®¡æ•°æ®
            totalWins.textContent = gameState.playerWins;
            totalRounds.textContent = gameState.totalRounds;
            
            // è®¡ç®—èƒœç‡
            const winRateValue = gameState.totalRounds > 0 
                ? Math.round((gameState.playerWins / gameState.totalRounds) * 100) 
                : 0;
            winRate.textContent = `${winRateValue}%`;
            
            if (isPlayerWin) {
                victoryTitle.textContent = "ğŸ‰ æ­å–œè·èƒœï¼";
                victoryMessage.textContent = `æ­å–œ${gameState.players[0].name}ï¼ä½ å·²è·å¾—${gameState.playerWins}åœºèƒœåˆ©ï¼`;
                saveVictoryBtn.style.display = 'flex';
                victoryStats.style.display = 'flex';
            } else {
                victoryTitle.textContent = "ğŸ’« æ¸¸æˆç»“æŸ";
                victoryMessage.textContent = "æ¸¸æˆç»“æŸï¼Œä¸‹æ¬¡åŠªåŠ›ï¼ç»§ç»­å­¦ä¹ åŒ–å­¦çŸ¥è¯†ï¼Œäº‰å–ä¸‹æ¬¡è·èƒœï¼";
                saveVictoryBtn.style.display = 'none';
                victoryStats.style.display = 'flex';
            }
            victoryScreen.style.display = 'flex';
        }
        
        // å…³é—­èƒœåˆ©ç•Œé¢
        function closeVictoryScreen() {
            victoryScreen.style.display = 'none';
            resetGameState();
        }
        
        // é‡ç½®æ¸¸æˆçŠ¶æ€ä½†ä¿ç•™èŠå¤©è®°å½•
        function resetGameState() {
            gameState = {
                currentPlayer: 0,
                players: [
                    { name: gameState.players[0].name, avatar: 'ğŸ‘¨â€ğŸ”¬', status: 'ç­‰å¾…æè¿°', concept: '', role: '', votes: 0, eliminated: false },
                    { name: 'å®éªŒå°æ', avatar: 'ğŸ‘©â€ğŸ”¬', status: 'ç­‰å¾…ä¸­', concept: '', role: '', votes: 0, eliminated: false },
                    { name: 'ååº”å°å¼ ', avatar: 'ğŸ§‘â€ğŸ”¬', status: 'ç­‰å¾…ä¸­', concept: '', role: '', votes: 0, eliminated: false },
                    { name: 'å…ƒç´ å°èµµ', avatar: 'ğŸ‘¨â€ğŸ’¼', status: 'ç­‰å¾…ä¸­', concept: '', role: '', votes: 0, eliminated: false }
                ],
                gamePhase: 'setup',
                concepts: [],
                usedConceptPairs: [...gameState.usedConceptPairs],
                currentAIPlayerIndex: 1,
                userVoted: false,
                aiVotes: [],
                roleRevealed: false,
                playerWins: gameState.playerWins,
                totalRounds: gameState.totalRounds,
                tiePlayers: [],
                tieRound: 0,
                maxTieRounds: 3,
                roundNumber: gameState.roundNumber + 1,
                waitingForUserTieDescription: null,
                selectedKnowledgePoints: gameState.selectedKnowledgePoints,
                currentConcepts: {},
                knowledgeSummary: '',
                isMobile: gameState.isMobile,
                tieCount: 0,
                playerWon: false,
                currentVoteRecords: []
            };
            
            playerDescriptions = [];
            
            const randomPair = selectUnusedConceptPair();
            const undercoverIndex = Math.floor(Math.random() * 4);
            
            for (let i = 0; i < 4; i++) {
                if (i === undercoverIndex) {
                    gameState.players[i].concept = randomPair.undercover;
                    gameState.players[i].role = 'å§åº•';
                } else {
                    gameState.players[i].concept = randomPair.chemist;
                    gameState.players[i].role = 'åŒ–å­¦å®¶';
                }
            }
            
            gameState.currentConcepts = {
                chemist: randomPair.chemist,
                undercover: randomPair.undercover
            };
            
            myConcept.textContent = gameState.players[0].concept;
            myRole.textContent = "æ¸¸æˆç»“æŸåæ­ç¤º";
            myRole.className = "concept-role";
            
            addSystemMessage(`ğŸ”„ ç¬¬${gameState.roundNumber}å›åˆå¼€å§‹ï¼`);
            updateStatus("æ¸¸æˆåˆå§‹åŒ–ä¸­", true);
            
            setTimeout(() => {
                generateKnowledgeSummary(randomPair.chemist, randomPair.undercover);
                
                addSystemMessage(`æ¬¢è¿å›åˆ°åŒ–å­¦å§åº•ï¼ç¬¬${gameState.roundNumber}å›åˆå¼€å§‹ï¼ä½ çš„æ¦‚å¿µæ˜¯"${gameState.players[0].concept}"ã€‚è¯·å¼€å§‹ä½ çš„æè¿°ã€‚`);
                updateStatus("è¯·æè¿°ä½ çš„æ¦‚å¿µ");
                updatePlayerCards();
                
                enableInput();
            }, 1500);
        }
        
        // æ˜¾ç¤ºçŸ¥è¯†ç‚¹æ€»ç»“
        function showSummary() {
            summaryText.textContent = gameState.knowledgeSummary;
            summaryModal.style.display = 'flex';
        }
        
        // å…³é—­çŸ¥è¯†ç‚¹æ€»ç»“
        function closeSummary() {
            summaryModal.style.display = 'none';
        }
        
        // ä¿å­˜èƒœåˆ©è®°å½•
        function saveVictory() {
            const playerName = gameState.players[0].name;
            alert(`èƒœåˆ©è®°å½•å·²ä¿å­˜ï¼\nç©å®¶: ${playerName}\nèƒœåˆ©æ¬¡æ•°: ${gameState.playerWins}\næ€»å±€æ•°: ${gameState.totalRounds}`);
        }
        
        // ä¿å­˜çŸ¥è¯†ç‚¹æ€»ç»“
        function saveSummary() {
            const summary = gameState.knowledgeSummary;
            const blob = new Blob([summary], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'åŒ–å­¦çŸ¥è¯†ç‚¹æ€»ç»“.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert('çŸ¥è¯†ç‚¹æ€»ç»“å·²ä¿å­˜ä¸ºæ–‡æœ¬æ–‡ä»¶ï¼');
        }
        
        // é€‰æ‹©æœªä½¿ç”¨è¿‡çš„æ¦‚å¿µå¯¹
        function selectUnusedConceptPair() {
            const conceptPairs = getConceptPairsFromSelectedKnowledge();
            
            const unusedPairs = conceptPairs.filter(pair => 
                !gameState.usedConceptPairs.some(used => 
                    (used.chemist === pair.chemist && used.undercover === pair.undercover) ||
                    (used.chemist === pair.undercover && used.undercover === pair.chemist)
                )
            );
            
            if (unusedPairs.length === 0) {
                gameState.usedConceptPairs = [];
                return selectUnusedConceptPair();
            }
            
            const randomIndex = Math.floor(Math.random() * unusedPairs.length);
            const selectedPair = unusedPairs[randomIndex];
            
            gameState.usedConceptPairs.push(selectedPair);
            
            return selectedPair;
        }
        
        // å¼€å§‹æ–°å›åˆ
        function startNewRound() {
            gameState.roundNumber++;
            
            gameState.players.forEach(player => {
                player.eliminated = false;
                player.votes = 0;
                player.status = player.name === gameState.players[0].name ? 'ç­‰å¾…æè¿°' : 'ç­‰å¾…ä¸­';
            });
            
            gameState.gamePhase = 'setup';
            gameState.currentPlayer = 0;
            gameState.currentAIPlayerIndex = 1;
            gameState.userVoted = false;
            gameState.aiVotes = [];
            gameState.roleRevealed = false;
            gameState.tiePlayers = [];
            gameState.tieRound = 0;
            gameState.tieCount = 0;
            gameState.playerWon = false;
            gameState.currentVoteRecords = [];
            
            playerDescriptions = [];
            
            const randomPair = selectUnusedConceptPair();
            const undercoverIndex = Math.floor(Math.random() * 4);
            
            for (let i = 0; i < 4; i++) {
                if (i === undercoverIndex) {
                    gameState.players[i].concept = randomPair.undercover;
                    gameState.players[i].role = 'å§åº•';
                } else {
                    gameState.players[i].concept = randomPair.chemist;
                    gameState.players[i].role = 'åŒ–å­¦å®¶';
                }
            }
            
            myConcept.textContent = gameState.players[0].concept;
            myRole.textContent = "æ¸¸æˆç»“æŸåæ­ç¤º";
            myRole.className = "concept-role";
            
            updatePlayerCards();
            
            addSystemMessage(`ç¬¬${gameState.roundNumber}å›åˆå¼€å§‹ï¼ä½ çš„æ¦‚å¿µæ˜¯"${gameState.players[0].concept}"ã€‚è¯·å¼€å§‹ä½ çš„æè¿°ã€‚`);
            updateStatus("è¯·æè¿°ä½ çš„æ¦‚å¿µ");
            
            if (!gameState.players[0].eliminated) {
                enableInput();
            }
        }
        
        // é‡ç½®çŠ¶æ€ä»¥ä¾¿å¼€å§‹æ–°ä¸€è½®
        function resetForNewRound() {
            gameState.players.forEach(player => {
                player.votes = 0;
            });
            gameState.userVoted = false;
            gameState.aiVotes = [];
            gameState.tieCount = 0;
            gameState.playerWon = false;
            gameState.currentVoteRecords = [];
            
            playerDescriptions = [];
            
            for (let i = 0; i < 4; i++) {
                if (!gameState.players[i].eliminated) {
                    gameState.players[i].status = i === 0 ? "ç­‰å¾…æè¿°" : "ç­‰å¾…ä¸­";
                } else {
                    gameState.players[i].status = "å·²æ·˜æ±°ï¼ˆè§‚æˆ˜ä¸­ï¼‰";
                }
            }
            
            gameState.gamePhase = 'describing';
            gameState.currentPlayer = 0;
            gameState.currentAIPlayerIndex = 1;
            gameState.roleRevealed = false;
            gameState.tiePlayers = [];
            gameState.tieRound = 0;
            
            updatePlayerCards();
            
            if (!gameState.players[0].eliminated) {
                updateStatus("è¯·æè¿°ä½ çš„æ¦‚å¿µ");
                enableInput();
            } else {
                updateStatus("ä½ å·²è¢«æ·˜æ±°ï¼Œæ­£åœ¨è§‚æˆ˜");
                setTimeout(continueAIPlayerDescriptions, 1000);
            }
        }
        
        // å¯ç”¨è¾“å…¥æ¡†
        function enableInput() {
            if (!gameState.players[0].eliminated) {
                playerInput.disabled = false;
                sendBtn.disabled = false;
                playerInput.focus();
            }
        }
        
        // ç¦ç”¨è¾“å…¥æ¡†
        function disableInput() {
            playerInput.disabled = true;
            sendBtn.disabled = true;
        }
        
        // å‘é€æ¶ˆæ¯
        async function sendMessage() {
            if (gameState.players[0].eliminated) {
                addErrorMessage("ä½ å·²è¢«æ·˜æ±°ï¼Œä¸èƒ½å‘è¨€");
                return;
            }
            
            const userMessage = playerInput.value.trim();
            if (!userMessage) return;
            
            const validation = validateDescription(userMessage, gameState.players[0].concept);
            if (!validation.isValid) {
                addErrorMessage(validation.error);
                playerInput.classList.add('error');
                setTimeout(() => {
                    playerInput.classList.remove('error');
                }, 2000);
                return;
            }
            
            disableInput();
            
            addMessage(gameState.players[0].name, userMessage, "user");
            playerDescriptions.push({ 
                player: gameState.players[0].name, 
                description: userMessage,
                isTieDescription: gameState.gamePhase === 'tie-describing'
            });
            playerInput.value = '';
            
            gameState.players[0].status = gameState.gamePhase === 'tie-describing' ? 
                "å·²å®Œæˆè¡¥å……æè¿°" : "å·²å®Œæˆæè¿°";
            updatePlayerCards();
            
            if (gameState.gamePhase === 'tie-describing' && gameState.waitingForUserTieDescription) {
                const { tiePlayerIndices, nextIndex } = gameState.waitingForUserTieDescription;
                gameState.waitingForUserTieDescription = null;
                startSequentialTieDescription(tiePlayerIndices, nextIndex);
                return;
            }
            
            updateStatus("AIç©å®¶æè¿°ä¸­");
            setTimeout(continueAIPlayerDescriptions, 1000);
        }
        
        // å¼€å§‹æ–°æ¸¸æˆ
        function startNewGame() {
            const playerName = playerNameInput.value.trim();
            if (!playerName) {
                alert("è¯·è¾“å…¥ä½ çš„æ˜µç§°æˆ–å§“åï¼");
                return;
            }
            
            const selectedPoints = getSelectedKnowledgePoints();
            if (selectedPoints.length === 0) {
                alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªçŸ¥è¯†ç‚¹ï¼");
                return;
            }
            
            startScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            
            gameState.players[0].name = playerName;
            player1Name.textContent = playerName;
            
            gameState.selectedKnowledgePoints = selectedPoints;
            
            gameState = {
                currentPlayer: 0,
                players: [
                    { name: playerName, avatar: 'ğŸ‘¨â€ğŸ”¬', status: 'ç­‰å¾…æè¿°', concept: '', role: '', votes: 0, eliminated: false },
                    { name: 'å®éªŒå°æ', avatar: 'ğŸ‘©â€ğŸ”¬', status: 'ç­‰å¾…ä¸­', concept: '', role: '', votes: 0, eliminated: false },
                    { name: 'ååº”å°å¼ ', avatar: 'ğŸ§‘â€ğŸ”¬', status: 'ç­‰å¾…ä¸­', concept: '', role: '', votes: 0, eliminated: false },
                    { name: 'å…ƒç´ å°èµµ', avatar: 'ğŸ‘¨â€ğŸ’¼', status: 'ç­‰å¾…ä¸­', concept: '', role: '', votes: 0, eliminated: false }
                ],
                gamePhase: 'setup',
                concepts: [],
                usedConceptPairs: [],
                currentAIPlayerIndex: 1,
                userVoted: false,
                aiVotes: [],
                roleRevealed: false,
                playerWins: 0,
                totalRounds: 0,
                tiePlayers: [],
                tieRound: 0,
                maxTieRounds: 3,
                roundNumber: 1,
                waitingForUserTieDescription: null,
                selectedKnowledgePoints: selectedPoints,
                currentConcepts: {},
                knowledgeSummary: '',
                isMobile: window.innerWidth <= 768,
                tieCount: 0,
                playerWon: false,
                currentVoteRecords: []
            };
            
            playerDescriptions = [];
            gameLog.innerHTML = '';
            
            const randomPair = selectUnusedConceptPair();
            const undercoverIndex = Math.floor(Math.random() * 4);
            
            for (let i = 0; i < 4; i++) {
                if (i === undercoverIndex) {
                    gameState.players[i].concept = randomPair.undercover;
                    gameState.players[i].role = 'å§åº•';
                } else {
                    gameState.players[i].concept = randomPair.chemist;
                    gameState.players[i].role = 'åŒ–å­¦å®¶';
                }
            }
            
            gameState.currentConcepts = {
                chemist: randomPair.chemist,
                undercover: randomPair.undercover
            };
            
            myConcept.textContent = gameState.players[0].concept;
            myRole.textContent = "æ¸¸æˆç»“æŸåæ­ç¤º";
            myRole.className = "concept-role";
            
            addSystemMessage("ğŸ”„ æ¸¸æˆå¼€å§‹ï¼");
            updateStatus("æ¸¸æˆåˆå§‹åŒ–ä¸­", true);
            
            setTimeout(() => {
                generateKnowledgeSummary(randomPair.chemist, randomPair.undercover);
                
                addSystemMessage(`æ¬¢è¿æ¥åˆ°åŒ–å­¦å§åº•ï¼ç¬¬${gameState.roundNumber}å›åˆå¼€å§‹ï¼ä½ çš„æ¦‚å¿µæ˜¯"${gameState.players[0].concept}"ã€‚è¯·å¼€å§‹ä½ çš„æè¿°ã€‚`);
                updateStatus("è¯·æè¿°ä½ çš„æ¦‚å¿µ");
                updatePlayerCards();
                
                if (gameState.isMobile) {
                    collapseVotingCards();
                }
                
                enableInput();
            }, 1500);
        }
        
        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            if (confirm("ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿå½“å‰æ¸¸æˆè¿›åº¦å°†è¢«æ¸…ç©ºã€‚")) {
                gameState.playerWins = 0;
                gameState.totalRounds = 0;
                gameState.usedConceptPairs = [];
                startNewGame();
            }
        }
        
        // æ¸…ç©ºå¯¹è¯
        function clearChat() {
            if (confirm("ç¡®å®šè¦æ¸…ç©ºå¯¹è¯è®°å½•å—ï¼Ÿ")) {
                gameLog.innerHTML = '';
                addSystemMessage("å¯¹è¯å·²æ¸…ç©ºã€‚æ¸¸æˆå¯ä»¥ç»§ç»­ã€‚");
            }
        }
        
        // æ˜¾ç¤ºæ¸¸æˆè§„åˆ™
        function showRules() {
            alert(`åŒ–å­¦å§åº•æ¸¸æˆè§„åˆ™ï¼š

1. ç©å®¶ä¾æ¬¡ç”¨ä¸€å¥è¯æè¿°è‡ªå·±æ‹¿åˆ°çš„åŒ–å­¦æ¦‚å¿µï¼Œæè¿°ä¸èƒ½ç›´æ¥è¯´å‡ºå®Œæ•´çš„æ¦‚å¿µåç§°ï¼Œæ‰€æœ‰ç©å®¶æè¿°å®Œæ¯•åè¿›è¡ŒæŠ•ç¥¨ï¼Œæ‰¾å‡ºå§åº•
2. å¹³ç¥¨æ—¶ï¼Œå¹³ç¥¨ç©å®¶è¿›è¡Œé¢å¤–æè¿°ï¼Œç„¶åé‡æ–°æŠ•ç¥¨
3. å¦‚æœå¹³ç¥¨å‘ç”Ÿ3æ¬¡ï¼Œéšæœºæ·˜æ±°ä¸€åå¹³ç¥¨é€‰æ‰‹
4. å§åº•è¦å°½é‡æ¨¡ä»¿åŒ–å­¦å®¶çš„æè¿°ï¼Œé¿å…è¢«å‘ç°
5. è·å¾—1åœºèƒœåˆ©åï¼Œç»“æŸæ¸¸æˆ`);
        }
        
        // æŒ‰å›è½¦é”®å‘é€æ¶ˆæ¯
        playerInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !sendBtn.disabled) {
                sendMessage();
            }
        });
        
        // é¦–é¡µè¾“å…¥å§“åæ—¶æ”¯æŒEnteré”®ç¡®è®¤
        playerNameInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                startNewGame();
            }
        });
        
        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.onload = function() {
            updateStatus("ç­‰å¾…æ¸¸æˆå¼€å§‹");
            disableInput();
            initializeKnowledgeSelection();
            
            window.addEventListener('resize', function() {
                gameState.isMobile = window.innerWidth <= 768;
            });
        };
    </script>
</body>
</html>